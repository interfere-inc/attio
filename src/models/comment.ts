/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

export type CommentId = {
  /**
   * The ID of the workspace the comment belongs to.
   */
  workspaceId: string;
  /**
   * The ID of the comment.
   */
  commentId: string;
};

/**
 * The entry the comment belongs to, `null` for comments on records.
 */
export type Entry = {
  /**
   * The ID of the entry the comment belongs to.
   */
  entryId: string;
  /**
   * The ID of the list the entry belongs to.
   */
  listId: string;
};

/**
 * The record the comment belongs to.
 */
export type RecordT = {
  /**
   * The ID of the record the comment belongs to.
   */
  recordId: string;
  /**
   * The ID of the object the record belongs to.
   */
  objectId: string;
};

/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export const ResolvedByType = {
  ApiToken: "api-token",
  WorkspaceMember: "workspace-member",
  System: "system",
  App: "app",
} as const;
/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export type ResolvedByType = OpenEnum<typeof ResolvedByType>;

/**
 * The actor that resolved this comment.
 */
export type ResolvedBy = {
  /**
   * An ID to identify the actor.
   */
  id?: string | null | undefined;
  /**
   * The type of actor. [Read more information on actor types here](/docs/actors).
   */
  type?: ResolvedByType | null | undefined;
};

/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export const AuthorType = {
  ApiToken: "api-token",
  WorkspaceMember: "workspace-member",
  System: "system",
  App: "app",
} as const;
/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export type AuthorType = OpenEnum<typeof AuthorType>;

/**
 * Who wrote this comment. Note that the API provides the ability for API tokens to write comments on behalf of other actors.
 */
export type Author = {
  /**
   * An ID to identify the actor.
   */
  id?: string | null | undefined;
  /**
   * The type of actor. [Read more information on actor types here](/docs/actors).
   */
  type?: AuthorType | null | undefined;
};

export type Comment = {
  id: CommentId;
  /**
   * The ID of the thread the comment belongs to.
   */
  threadId: string;
  /**
   * A plaintext representation of the content of the comment. References to workspace members are cast into email addresses, all other stylistic elements are removed.
   */
  contentPlaintext: string;
  /**
   * The entry the comment belongs to, `null` for comments on records.
   */
  entry: Entry | null;
  /**
   * The record the comment belongs to.
   */
  record: RecordT;
  /**
   * Whether the comment is resolved.
   */
  resolvedAt: string | null;
  /**
   * The actor that resolved this comment.
   */
  resolvedBy: ResolvedBy;
  /**
   * When the note was created.
   */
  createdAt: string;
  /**
   * Who wrote this comment. Note that the API provides the ability for API tokens to write comments on behalf of other actors.
   */
  author: Author;
};

/** @internal */
export const CommentId$inboundSchema: z.ZodMiniType<CommentId, unknown> = z
  .pipe(
    z.object({
      workspace_id: types.string(),
      comment_id: types.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        "workspace_id": "workspaceId",
        "comment_id": "commentId",
      });
    }),
  );

export function commentIdFromJSON(
  jsonString: string,
): SafeParseResult<CommentId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CommentId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CommentId' from JSON`,
  );
}

/** @internal */
export const Entry$inboundSchema: z.ZodMiniType<Entry, unknown> = z.pipe(
  z.object({
    entry_id: types.string(),
    list_id: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "entry_id": "entryId",
      "list_id": "listId",
    });
  }),
);

export function entryFromJSON(
  jsonString: string,
): SafeParseResult<Entry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Entry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Entry' from JSON`,
  );
}

/** @internal */
export const RecordT$inboundSchema: z.ZodMiniType<RecordT, unknown> = z.pipe(
  z.object({
    record_id: types.string(),
    object_id: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "record_id": "recordId",
      "object_id": "objectId",
    });
  }),
);

export function recordFromJSON(
  jsonString: string,
): SafeParseResult<RecordT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RecordT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RecordT' from JSON`,
  );
}

/** @internal */
export const ResolvedByType$inboundSchema: z.ZodMiniType<
  ResolvedByType,
  unknown
> = openEnums.inboundSchema(ResolvedByType);

/** @internal */
export const ResolvedBy$inboundSchema: z.ZodMiniType<ResolvedBy, unknown> = z
  .object({
    id: z.optional(z.nullable(types.string())),
    type: z.optional(z.nullable(ResolvedByType$inboundSchema)),
  });

export function resolvedByFromJSON(
  jsonString: string,
): SafeParseResult<ResolvedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResolvedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResolvedBy' from JSON`,
  );
}

/** @internal */
export const AuthorType$inboundSchema: z.ZodMiniType<AuthorType, unknown> =
  openEnums.inboundSchema(AuthorType);

/** @internal */
export const Author$inboundSchema: z.ZodMiniType<Author, unknown> = z.object({
  id: z.optional(z.nullable(types.string())),
  type: z.optional(z.nullable(AuthorType$inboundSchema)),
});

export function authorFromJSON(
  jsonString: string,
): SafeParseResult<Author, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Author$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Author' from JSON`,
  );
}

/** @internal */
export const Comment$inboundSchema: z.ZodMiniType<Comment, unknown> = z.pipe(
  z.object({
    id: z.lazy(() => CommentId$inboundSchema),
    thread_id: types.string(),
    content_plaintext: types.string(),
    entry: types.nullable(z.lazy(() => Entry$inboundSchema)),
    record: z.lazy(() => RecordT$inboundSchema),
    resolved_at: types.nullable(types.string()),
    resolved_by: z.lazy(() => ResolvedBy$inboundSchema),
    created_at: types.string(),
    author: z.lazy(() => Author$inboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      "thread_id": "threadId",
      "content_plaintext": "contentPlaintext",
      "resolved_at": "resolvedAt",
      "resolved_by": "resolvedBy",
      "created_at": "createdAt",
    });
  }),
);

export function commentFromJSON(
  jsonString: string,
): SafeParseResult<Comment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Comment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Comment' from JSON`,
  );
}
