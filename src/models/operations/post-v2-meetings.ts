/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { smartUnion } from "../../types/smart-union.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";
import * as models from "../index.js";

export type Start2 = {
  /**
   * An ISO 8601 date indicating when an all day meeting starts.
   */
  date: string;
};

export type Start1 = {
  /**
   * An ISO 8601 datetime indicating when a non-all day meeting starts.
   */
  datetime: Date;
  /**
   * The IANA timezone the meeting starts in. If a datetime value is provided without an offset, this timezone will be used to convert the datetime to UTC using the timezone offset. If a datetime value is provided with an offset, this timezone will not be used to apply any additional offset to the datetime. Invalid timezones will be treated as UTC.
   */
  timezone?: string | null | undefined;
};

/**
 * When the meeting starts. Use a datetime and optional timezone for non-all day meetings, or a date for all day meetings.
 */
export type StartUnion = Start1 | Start2;

export type End2 = {
  /**
   * An ISO 8601 date indicating when an all day meeting ends. Note that dates are exclusive, meaning that the meeting ends before the specified time, not at it. For example, a one day meeting on June 3rd would end on June 4th, not June 3rd.
   */
  date: string;
};

export type End1 = {
  /**
   * An ISO 8601 datetime indicating when a non-all day meeting ends. Note that this value is exclusive, meaning that the meeting ends before the specified time, not at it. For example, a one hour meeting starting at 14:00 would end at 15:00, not 15:59:59.
   */
  datetime: Date;
  /**
   * The IANA timezone the meeting ends in. If a datetime value is provided without an offset, this timezone will be used to convert the datetime to UTC using the timezone offset. If a datetime value is provided with an offset, this timezone will not be used to apply any additional offset to the datetime. Invalid timezones will be treated as UTC.
   */
  timezone?: string | null | undefined;
};

/**
 * When the meeting ends. Use a datetime and optional timezone for non-all day meetings, or a date for all day meetings.
 */
export type EndUnion = End1 | End2;

export const IsOrganizerFalse = {
  False: "false",
} as const;
export type IsOrganizerFalse = ClosedEnum<typeof IsOrganizerFalse>;

export const IsOrganizerTrue = {
  True: "true",
} as const;
export type IsOrganizerTrue = ClosedEnum<typeof IsOrganizerTrue>;

/**
 * Whether or not the participant is the organizer of the meeting.
 */
export type IsOrganizer = boolean | IsOrganizerTrue | IsOrganizerFalse;

/**
 * The status of the individual meeting participant.
 */
export const PostV2MeetingsStatus = {
  Accepted: "accepted",
  Tentative: "tentative",
  Declined: "declined",
  Pending: "pending",
} as const;
/**
 * The status of the individual meeting participant.
 */
export type PostV2MeetingsStatus = ClosedEnum<typeof PostV2MeetingsStatus>;

export type Participant = {
  /**
   * The email address of the participant. New person records and companies will automatically be created based upon the email address values provided.
   */
  emailAddress: string;
  /**
   * Whether or not the participant is the organizer of the meeting.
   */
  isOrganizer: boolean | IsOrganizerTrue | IsOrganizerFalse;
  /**
   * The status of the individual meeting participant.
   */
  status: PostV2MeetingsStatus;
};

export type PostV2MeetingsLinkedRecord = {
  /**
   * The slug or UUID of the object that the record being linked belongs to.
   */
  object: string;
  /**
   * The UUID of the record being linked.
   */
  recordId: string;
};

/**
 * The email provider used to sync the meeting.
 */
export const Provider = {
  Google: "google",
  Microsoft: "microsoft",
} as const;
/**
 * The email provider used to sync the meeting.
 */
export type Provider = ClosedEnum<typeof Provider>;

export type ExternalRef = {
  /**
   * The ical uid of the meeting.
   */
  icalUid: string;
  /**
   * The email provider used to sync the meeting.
   */
  provider: Provider;
  /**
   * The original start time of the meeting. Use a timestamp with a specified offset for all day and non-all day meetings. This property is required for recurring event exceptions and optional otherwise.
   */
  originalStartTime?: string | undefined;
  /**
   * Whether or not the meeting is recurring.
   */
  isRecurring: boolean;
};

/**
 * A consistent external reference used to match and de-duplicate meetings. Can be either a plain string (for external system IDs) or an object with `ical_uid` and `provider`. If you are writing data into Attio which is based upon calendar events that you have synced from a Google or Microsoft calendar, you must use the iCal format to avoid creating duplicate meetings inside Attio.
 */
export type ExternalRefUnion = ExternalRef | string;

export type PostV2MeetingsData = {
  /**
   * The title of the meeting.
   */
  title: string;
  /**
   * The description of the meeting.
   */
  description: string;
  /**
   * When the meeting starts. Use a datetime and optional timezone for non-all day meetings, or a date for all day meetings.
   */
  start: Start1 | Start2;
  /**
   * When the meeting ends. Use a datetime and optional timezone for non-all day meetings, or a date for all day meetings.
   */
  end: End1 | End2;
  /**
   * Whether or not the meeting is an all day event. All day events may span multiple days. When true, start and end must use date format. When false, start and end must use datetime with timezone format.
   */
  isAllDay: boolean;
  participants: Array<Participant>;
  /**
   * A list of records to link to the meeting. Each record is specified by its object (slug or UUID) and record ID (UUID). Attio will automatically link the meeting participants' companies to the meeting; this behavior is asynchronous.
   */
  linkedRecords?: Array<PostV2MeetingsLinkedRecord> | undefined;
  /**
   * A consistent external reference used to match and de-duplicate meetings. Can be either a plain string (for external system IDs) or an object with `ical_uid` and `provider`. If you are writing data into Attio which is based upon calendar events that you have synced from a Google or Microsoft calendar, you must use the iCal format to avoid creating duplicate meetings inside Attio.
   */
  externalRef: ExternalRef | string;
};

export type PostV2MeetingsRequest = {
  data: PostV2MeetingsData;
};

export const PostV2MeetingsType = {
  InvalidRequestError: "invalid_request_error",
} as const;
export type PostV2MeetingsType = ClosedEnum<typeof PostV2MeetingsType>;

export const PostV2MeetingsCode = {
  ValidationType: "validation_type",
} as const;
export type PostV2MeetingsCode = ClosedEnum<typeof PostV2MeetingsCode>;

/**
 * Success
 */
export type PostV2MeetingsResponse = {
  data: models.Meeting;
};

/** @internal */
export type Start2$Outbound = {
  date: string;
};

/** @internal */
export const Start2$outboundSchema: z.ZodMiniType<Start2$Outbound, Start2> = z
  .object({
    date: z.string(),
  });

export function start2ToJSON(start2: Start2): string {
  return JSON.stringify(Start2$outboundSchema.parse(start2));
}

/** @internal */
export type Start1$Outbound = {
  datetime: string;
  timezone?: string | null | undefined;
};

/** @internal */
export const Start1$outboundSchema: z.ZodMiniType<Start1$Outbound, Start1> = z
  .object({
    datetime: z.pipe(z.date(), z.transform(v => v.toISOString())),
    timezone: z.optional(z.nullable(z.string())),
  });

export function start1ToJSON(start1: Start1): string {
  return JSON.stringify(Start1$outboundSchema.parse(start1));
}

/** @internal */
export type StartUnion$Outbound = Start1$Outbound | Start2$Outbound;

/** @internal */
export const StartUnion$outboundSchema: z.ZodMiniType<
  StartUnion$Outbound,
  StartUnion
> = smartUnion([
  z.lazy(() => Start1$outboundSchema),
  z.lazy(() => Start2$outboundSchema),
]);

export function startUnionToJSON(startUnion: StartUnion): string {
  return JSON.stringify(StartUnion$outboundSchema.parse(startUnion));
}

/** @internal */
export type End2$Outbound = {
  date: string;
};

/** @internal */
export const End2$outboundSchema: z.ZodMiniType<End2$Outbound, End2> = z.object(
  {
    date: z.string(),
  },
);

export function end2ToJSON(end2: End2): string {
  return JSON.stringify(End2$outboundSchema.parse(end2));
}

/** @internal */
export type End1$Outbound = {
  datetime: string;
  timezone?: string | null | undefined;
};

/** @internal */
export const End1$outboundSchema: z.ZodMiniType<End1$Outbound, End1> = z.object(
  {
    datetime: z.pipe(z.date(), z.transform(v => v.toISOString())),
    timezone: z.optional(z.nullable(z.string())),
  },
);

export function end1ToJSON(end1: End1): string {
  return JSON.stringify(End1$outboundSchema.parse(end1));
}

/** @internal */
export type EndUnion$Outbound = End1$Outbound | End2$Outbound;

/** @internal */
export const EndUnion$outboundSchema: z.ZodMiniType<
  EndUnion$Outbound,
  EndUnion
> = smartUnion([
  z.lazy(() => End1$outboundSchema),
  z.lazy(() => End2$outboundSchema),
]);

export function endUnionToJSON(endUnion: EndUnion): string {
  return JSON.stringify(EndUnion$outboundSchema.parse(endUnion));
}

/** @internal */
export const IsOrganizerFalse$outboundSchema: z.ZodMiniEnum<
  typeof IsOrganizerFalse
> = z.enum(IsOrganizerFalse);

/** @internal */
export const IsOrganizerTrue$outboundSchema: z.ZodMiniEnum<
  typeof IsOrganizerTrue
> = z.enum(IsOrganizerTrue);

/** @internal */
export type IsOrganizer$Outbound = boolean | string | string;

/** @internal */
export const IsOrganizer$outboundSchema: z.ZodMiniType<
  IsOrganizer$Outbound,
  IsOrganizer
> = smartUnion([
  z.boolean(),
  IsOrganizerTrue$outboundSchema,
  IsOrganizerFalse$outboundSchema,
]);

export function isOrganizerToJSON(isOrganizer: IsOrganizer): string {
  return JSON.stringify(IsOrganizer$outboundSchema.parse(isOrganizer));
}

/** @internal */
export const PostV2MeetingsStatus$outboundSchema: z.ZodMiniEnum<
  typeof PostV2MeetingsStatus
> = z.enum(PostV2MeetingsStatus);

/** @internal */
export type Participant$Outbound = {
  email_address: string;
  is_organizer: boolean | string | string;
  status: string;
};

/** @internal */
export const Participant$outboundSchema: z.ZodMiniType<
  Participant$Outbound,
  Participant
> = z.pipe(
  z.object({
    emailAddress: z.string(),
    isOrganizer: smartUnion([
      z.boolean(),
      IsOrganizerTrue$outboundSchema,
      IsOrganizerFalse$outboundSchema,
    ]),
    status: PostV2MeetingsStatus$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      emailAddress: "email_address",
      isOrganizer: "is_organizer",
    });
  }),
);

export function participantToJSON(participant: Participant): string {
  return JSON.stringify(Participant$outboundSchema.parse(participant));
}

/** @internal */
export type PostV2MeetingsLinkedRecord$Outbound = {
  object: string;
  record_id: string;
};

/** @internal */
export const PostV2MeetingsLinkedRecord$outboundSchema: z.ZodMiniType<
  PostV2MeetingsLinkedRecord$Outbound,
  PostV2MeetingsLinkedRecord
> = z.pipe(
  z.object({
    object: z.string(),
    recordId: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      recordId: "record_id",
    });
  }),
);

export function postV2MeetingsLinkedRecordToJSON(
  postV2MeetingsLinkedRecord: PostV2MeetingsLinkedRecord,
): string {
  return JSON.stringify(
    PostV2MeetingsLinkedRecord$outboundSchema.parse(postV2MeetingsLinkedRecord),
  );
}

/** @internal */
export const Provider$outboundSchema: z.ZodMiniEnum<typeof Provider> = z.enum(
  Provider,
);

/** @internal */
export type ExternalRef$Outbound = {
  ical_uid: string;
  provider: string;
  original_start_time?: string | undefined;
  is_recurring: boolean;
};

/** @internal */
export const ExternalRef$outboundSchema: z.ZodMiniType<
  ExternalRef$Outbound,
  ExternalRef
> = z.pipe(
  z.object({
    icalUid: z.string(),
    provider: Provider$outboundSchema,
    originalStartTime: z.optional(z.string()),
    isRecurring: z.boolean(),
  }),
  z.transform((v) => {
    return remap$(v, {
      icalUid: "ical_uid",
      originalStartTime: "original_start_time",
      isRecurring: "is_recurring",
    });
  }),
);

export function externalRefToJSON(externalRef: ExternalRef): string {
  return JSON.stringify(ExternalRef$outboundSchema.parse(externalRef));
}

/** @internal */
export type ExternalRefUnion$Outbound = ExternalRef$Outbound | string;

/** @internal */
export const ExternalRefUnion$outboundSchema: z.ZodMiniType<
  ExternalRefUnion$Outbound,
  ExternalRefUnion
> = smartUnion([z.lazy(() => ExternalRef$outboundSchema), z.string()]);

export function externalRefUnionToJSON(
  externalRefUnion: ExternalRefUnion,
): string {
  return JSON.stringify(
    ExternalRefUnion$outboundSchema.parse(externalRefUnion),
  );
}

/** @internal */
export type PostV2MeetingsData$Outbound = {
  title: string;
  description: string;
  start: Start1$Outbound | Start2$Outbound;
  end: End1$Outbound | End2$Outbound;
  is_all_day: boolean;
  participants: Array<Participant$Outbound>;
  linked_records?: Array<PostV2MeetingsLinkedRecord$Outbound> | undefined;
  external_ref: ExternalRef$Outbound | string;
};

/** @internal */
export const PostV2MeetingsData$outboundSchema: z.ZodMiniType<
  PostV2MeetingsData$Outbound,
  PostV2MeetingsData
> = z.pipe(
  z.object({
    title: z.string(),
    description: z.string(),
    start: smartUnion([
      z.lazy(() => Start1$outboundSchema),
      z.lazy(() => Start2$outboundSchema),
    ]),
    end: smartUnion([
      z.lazy(() => End1$outboundSchema),
      z.lazy(() => End2$outboundSchema),
    ]),
    isAllDay: z.boolean(),
    participants: z.array(z.lazy(() => Participant$outboundSchema)),
    linkedRecords: z.optional(
      z.array(z.lazy(() => PostV2MeetingsLinkedRecord$outboundSchema)),
    ),
    externalRef: smartUnion([
      z.lazy(() => ExternalRef$outboundSchema),
      z.string(),
    ]),
  }),
  z.transform((v) => {
    return remap$(v, {
      isAllDay: "is_all_day",
      linkedRecords: "linked_records",
      externalRef: "external_ref",
    });
  }),
);

export function postV2MeetingsDataToJSON(
  postV2MeetingsData: PostV2MeetingsData,
): string {
  return JSON.stringify(
    PostV2MeetingsData$outboundSchema.parse(postV2MeetingsData),
  );
}

/** @internal */
export type PostV2MeetingsRequest$Outbound = {
  data: PostV2MeetingsData$Outbound;
};

/** @internal */
export const PostV2MeetingsRequest$outboundSchema: z.ZodMiniType<
  PostV2MeetingsRequest$Outbound,
  PostV2MeetingsRequest
> = z.object({
  data: z.lazy(() => PostV2MeetingsData$outboundSchema),
});

export function postV2MeetingsRequestToJSON(
  postV2MeetingsRequest: PostV2MeetingsRequest,
): string {
  return JSON.stringify(
    PostV2MeetingsRequest$outboundSchema.parse(postV2MeetingsRequest),
  );
}

/** @internal */
export const PostV2MeetingsType$inboundSchema: z.ZodMiniEnum<
  typeof PostV2MeetingsType
> = z.enum(PostV2MeetingsType);

/** @internal */
export const PostV2MeetingsCode$inboundSchema: z.ZodMiniEnum<
  typeof PostV2MeetingsCode
> = z.enum(PostV2MeetingsCode);

/** @internal */
export const PostV2MeetingsResponse$inboundSchema: z.ZodMiniType<
  PostV2MeetingsResponse,
  unknown
> = z.object({
  data: models.Meeting$inboundSchema,
});

export function postV2MeetingsResponseFromJSON(
  jsonString: string,
): SafeParseResult<PostV2MeetingsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostV2MeetingsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2MeetingsResponse' from JSON`,
  );
}
