/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as discriminatedUnionTypes from "../../types/discriminated-union.js";
import { discriminatedUnion } from "../../types/discriminated-union.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { smartUnion } from "../../types/smart-union.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * Type of event the webhook is subscribed to.
 */
export const PatchV2WebhooksWebhookIdEventTypeRequest = {
  CallRecordingCreated: "call-recording.created",
  CommentCreated: "comment.created",
  CommentResolved: "comment.resolved",
  CommentUnresolved: "comment.unresolved",
  CommentDeleted: "comment.deleted",
  ListCreated: "list.created",
  ListUpdated: "list.updated",
  ListDeleted: "list.deleted",
  ListAttributeCreated: "list-attribute.created",
  ListAttributeUpdated: "list-attribute.updated",
  ListEntryCreated: "list-entry.created",
  ListEntryUpdated: "list-entry.updated",
  ListEntryDeleted: "list-entry.deleted",
  ObjectAttributeCreated: "object-attribute.created",
  ObjectAttributeUpdated: "object-attribute.updated",
  NoteCreated: "note.created",
  NoteContentUpdated: "note-content.updated",
  NoteUpdated: "note.updated",
  NoteDeleted: "note.deleted",
  RecordCreated: "record.created",
  RecordMerged: "record.merged",
  RecordUpdated: "record.updated",
  RecordDeleted: "record.deleted",
  TaskCreated: "task.created",
  TaskUpdated: "task.updated",
  TaskDeleted: "task.deleted",
  WorkspaceMemberCreated: "workspace-member.created",
} as const;
/**
 * Type of event the webhook is subscribed to.
 */
export type PatchV2WebhooksWebhookIdEventTypeRequest = ClosedEnum<
  typeof PatchV2WebhooksWebhookIdEventTypeRequest
>;

export type PatchV2WebhooksWebhookIdDollarAndNotEqualsRequest = {
  field: string;
  operator: "not_equals";
  value: string;
};

export type PatchV2WebhooksWebhookIdDollarAndEqualsRequest = {
  field: string;
  operator: "equals";
  value: string;
};

export type PatchV2WebhooksWebhookIdDollarAndRequestUnion =
  | PatchV2WebhooksWebhookIdDollarAndEqualsRequest
  | PatchV2WebhooksWebhookIdDollarAndNotEqualsRequest;

export type PatchV2WebhooksWebhookIdFilterRequest2 = {
  dollarAnd: Array<
    | PatchV2WebhooksWebhookIdDollarAndEqualsRequest
    | PatchV2WebhooksWebhookIdDollarAndNotEqualsRequest
  >;
};

export type PatchV2WebhooksWebhookIdDollarOrNotEqualsRequest = {
  field: string;
  operator: "not_equals";
  value: string;
};

export type PatchV2WebhooksWebhookIdDollarOrEqualsRequest = {
  field: string;
  operator: "equals";
  value: string;
};

export type PatchV2WebhooksWebhookIdDollarOrRequestUnion =
  | PatchV2WebhooksWebhookIdDollarOrEqualsRequest
  | PatchV2WebhooksWebhookIdDollarOrNotEqualsRequest;

export type PatchV2WebhooksWebhookIdFilterRequest1 = {
  dollarOr: Array<
    | PatchV2WebhooksWebhookIdDollarOrEqualsRequest
    | PatchV2WebhooksWebhookIdDollarOrNotEqualsRequest
  >;
};

/**
 * Filters to determine whether the webhook event should be sent. If null, the filter always passes.
 */
export type PatchV2WebhooksWebhookIdFilterRequestUnion =
  | PatchV2WebhooksWebhookIdFilterRequest1
  | PatchV2WebhooksWebhookIdFilterRequest2;

export type PatchV2WebhooksWebhookIdSubscriptionRequest = {
  /**
   * Type of event the webhook is subscribed to.
   */
  eventType: PatchV2WebhooksWebhookIdEventTypeRequest;
  /**
   * Filters to determine whether the webhook event should be sent. If null, the filter always passes.
   */
  filter:
    | PatchV2WebhooksWebhookIdFilterRequest1
    | PatchV2WebhooksWebhookIdFilterRequest2
    | null;
};

export type PatchV2WebhooksWebhookIdDataRequest = {
  /**
   * URL where the webhook events will be delivered to.
   */
  targetUrl?: string | undefined;
  /**
   * One or more events the webhook is subscribed to.
   */
  subscriptions?:
    | Array<PatchV2WebhooksWebhookIdSubscriptionRequest>
    | undefined;
};

export type PatchV2WebhooksWebhookIdRequestBody = {
  data: PatchV2WebhooksWebhookIdDataRequest;
};

export type PatchV2WebhooksWebhookIdRequest = {
  webhookId: string;
  body: PatchV2WebhooksWebhookIdRequestBody;
};

export const PatchV2WebhooksWebhookIdType = {
  InvalidRequestError: "invalid_request_error",
} as const;
export type PatchV2WebhooksWebhookIdType = ClosedEnum<
  typeof PatchV2WebhooksWebhookIdType
>;

export const PatchV2WebhooksWebhookIdCode = {
  NotFound: "not_found",
} as const;
export type PatchV2WebhooksWebhookIdCode = ClosedEnum<
  typeof PatchV2WebhooksWebhookIdCode
>;

/**
 * Type of event the webhook is subscribed to.
 */
export const PatchV2WebhooksWebhookIdEventTypeResponse = {
  CallRecordingCreated: "call-recording.created",
  CommentCreated: "comment.created",
  CommentResolved: "comment.resolved",
  CommentUnresolved: "comment.unresolved",
  CommentDeleted: "comment.deleted",
  ListCreated: "list.created",
  ListUpdated: "list.updated",
  ListDeleted: "list.deleted",
  ListAttributeCreated: "list-attribute.created",
  ListAttributeUpdated: "list-attribute.updated",
  ListEntryCreated: "list-entry.created",
  ListEntryUpdated: "list-entry.updated",
  ListEntryDeleted: "list-entry.deleted",
  ObjectAttributeCreated: "object-attribute.created",
  ObjectAttributeUpdated: "object-attribute.updated",
  NoteCreated: "note.created",
  NoteContentUpdated: "note-content.updated",
  NoteUpdated: "note.updated",
  NoteDeleted: "note.deleted",
  RecordCreated: "record.created",
  RecordMerged: "record.merged",
  RecordUpdated: "record.updated",
  RecordDeleted: "record.deleted",
  TaskCreated: "task.created",
  TaskUpdated: "task.updated",
  TaskDeleted: "task.deleted",
  WorkspaceMemberCreated: "workspace-member.created",
} as const;
/**
 * Type of event the webhook is subscribed to.
 */
export type PatchV2WebhooksWebhookIdEventTypeResponse = OpenEnum<
  typeof PatchV2WebhooksWebhookIdEventTypeResponse
>;

export type PatchV2WebhooksWebhookIdDollarAndNotEqualsResponse = {
  field: string;
  operator: "not_equals";
  value: string;
};

export type PatchV2WebhooksWebhookIdDollarAndEqualsResponse = {
  field: string;
  operator: "equals";
  value: string;
};

export type PatchV2WebhooksWebhookIdDollarAndResponseUnion =
  | PatchV2WebhooksWebhookIdDollarAndEqualsResponse
  | PatchV2WebhooksWebhookIdDollarAndNotEqualsResponse
  | discriminatedUnionTypes.Unknown<"operator">;

export type PatchV2WebhooksWebhookIdFilterResponse2 = {
  dollarAnd: Array<
    | PatchV2WebhooksWebhookIdDollarAndEqualsResponse
    | PatchV2WebhooksWebhookIdDollarAndNotEqualsResponse
    | discriminatedUnionTypes.Unknown<"operator">
  >;
};

export type PatchV2WebhooksWebhookIdDollarOrNotEqualsResponse = {
  field: string;
  operator: "not_equals";
  value: string;
};

export type PatchV2WebhooksWebhookIdDollarOrEqualsResponse = {
  field: string;
  operator: "equals";
  value: string;
};

export type PatchV2WebhooksWebhookIdDollarOrResponseUnion =
  | PatchV2WebhooksWebhookIdDollarOrEqualsResponse
  | PatchV2WebhooksWebhookIdDollarOrNotEqualsResponse
  | discriminatedUnionTypes.Unknown<"operator">;

export type PatchV2WebhooksWebhookIdFilterResponse1 = {
  dollarOr: Array<
    | PatchV2WebhooksWebhookIdDollarOrEqualsResponse
    | PatchV2WebhooksWebhookIdDollarOrNotEqualsResponse
    | discriminatedUnionTypes.Unknown<"operator">
  >;
};

/**
 * Filters to determine whether the webhook event should be sent. If null, the filter always passes.
 */
export type PatchV2WebhooksWebhookIdFilterResponseUnion =
  | PatchV2WebhooksWebhookIdFilterResponse1
  | PatchV2WebhooksWebhookIdFilterResponse2;

export type PatchV2WebhooksWebhookIdSubscriptionResponse = {
  /**
   * Type of event the webhook is subscribed to.
   */
  eventType: PatchV2WebhooksWebhookIdEventTypeResponse;
  /**
   * Filters to determine whether the webhook event should be sent. If null, the filter always passes.
   */
  filter:
    | PatchV2WebhooksWebhookIdFilterResponse1
    | PatchV2WebhooksWebhookIdFilterResponse2
    | null;
};

export type PatchV2WebhooksWebhookIdId = {
  /**
   * The ID of the workspace the webhook belongs to.
   */
  workspaceId: string;
  /**
   * The ID of the webhook.
   */
  webhookId: string;
};

/**
 * The state of the webhook. Webhooks marked as active and degraded will receive events, inactive ones will not. If a webhook remains in the degraded state for 7 days, it will be marked inactive.
 */
export const PatchV2WebhooksWebhookIdStatus = {
  Active: "active",
  Degraded: "degraded",
  Inactive: "inactive",
} as const;
/**
 * The state of the webhook. Webhooks marked as active and degraded will receive events, inactive ones will not. If a webhook remains in the degraded state for 7 days, it will be marked inactive.
 */
export type PatchV2WebhooksWebhookIdStatus = OpenEnum<
  typeof PatchV2WebhooksWebhookIdStatus
>;

export type PatchV2WebhooksWebhookIdDataResponse = {
  /**
   * URL where the webhook events will be delivered to.
   */
  targetUrl: string;
  /**
   * One or more events the webhook is subscribed to.
   */
  subscriptions: Array<PatchV2WebhooksWebhookIdSubscriptionResponse>;
  id: PatchV2WebhooksWebhookIdId;
  /**
   * The state of the webhook. Webhooks marked as active and degraded will receive events, inactive ones will not. If a webhook remains in the degraded state for 7 days, it will be marked inactive.
   */
  status: PatchV2WebhooksWebhookIdStatus;
  /**
   * When the webhook was created.
   */
  createdAt: string;
};

/**
 * Success
 */
export type PatchV2WebhooksWebhookIdResponse = {
  data: PatchV2WebhooksWebhookIdDataResponse;
};

/** @internal */
export const PatchV2WebhooksWebhookIdEventTypeRequest$outboundSchema:
  z.ZodMiniEnum<typeof PatchV2WebhooksWebhookIdEventTypeRequest> = z.enum(
    PatchV2WebhooksWebhookIdEventTypeRequest,
  );

/** @internal */
export type PatchV2WebhooksWebhookIdDollarAndNotEqualsRequest$Outbound = {
  field: string;
  operator: "not_equals";
  value: string;
};

/** @internal */
export const PatchV2WebhooksWebhookIdDollarAndNotEqualsRequest$outboundSchema:
  z.ZodMiniType<
    PatchV2WebhooksWebhookIdDollarAndNotEqualsRequest$Outbound,
    PatchV2WebhooksWebhookIdDollarAndNotEqualsRequest
  > = z.object({
    field: z.string(),
    operator: z.literal("not_equals"),
    value: z.string(),
  });

export function patchV2WebhooksWebhookIdDollarAndNotEqualsRequestToJSON(
  patchV2WebhooksWebhookIdDollarAndNotEqualsRequest:
    PatchV2WebhooksWebhookIdDollarAndNotEqualsRequest,
): string {
  return JSON.stringify(
    PatchV2WebhooksWebhookIdDollarAndNotEqualsRequest$outboundSchema.parse(
      patchV2WebhooksWebhookIdDollarAndNotEqualsRequest,
    ),
  );
}

/** @internal */
export type PatchV2WebhooksWebhookIdDollarAndEqualsRequest$Outbound = {
  field: string;
  operator: "equals";
  value: string;
};

/** @internal */
export const PatchV2WebhooksWebhookIdDollarAndEqualsRequest$outboundSchema:
  z.ZodMiniType<
    PatchV2WebhooksWebhookIdDollarAndEqualsRequest$Outbound,
    PatchV2WebhooksWebhookIdDollarAndEqualsRequest
  > = z.object({
    field: z.string(),
    operator: z.literal("equals"),
    value: z.string(),
  });

export function patchV2WebhooksWebhookIdDollarAndEqualsRequestToJSON(
  patchV2WebhooksWebhookIdDollarAndEqualsRequest:
    PatchV2WebhooksWebhookIdDollarAndEqualsRequest,
): string {
  return JSON.stringify(
    PatchV2WebhooksWebhookIdDollarAndEqualsRequest$outboundSchema.parse(
      patchV2WebhooksWebhookIdDollarAndEqualsRequest,
    ),
  );
}

/** @internal */
export type PatchV2WebhooksWebhookIdDollarAndRequestUnion$Outbound =
  | PatchV2WebhooksWebhookIdDollarAndEqualsRequest$Outbound
  | PatchV2WebhooksWebhookIdDollarAndNotEqualsRequest$Outbound;

/** @internal */
export const PatchV2WebhooksWebhookIdDollarAndRequestUnion$outboundSchema:
  z.ZodMiniType<
    PatchV2WebhooksWebhookIdDollarAndRequestUnion$Outbound,
    PatchV2WebhooksWebhookIdDollarAndRequestUnion
  > = z.union([
    z.lazy(() => PatchV2WebhooksWebhookIdDollarAndEqualsRequest$outboundSchema),
    z.lazy(() =>
      PatchV2WebhooksWebhookIdDollarAndNotEqualsRequest$outboundSchema
    ),
  ]);

export function patchV2WebhooksWebhookIdDollarAndRequestUnionToJSON(
  patchV2WebhooksWebhookIdDollarAndRequestUnion:
    PatchV2WebhooksWebhookIdDollarAndRequestUnion,
): string {
  return JSON.stringify(
    PatchV2WebhooksWebhookIdDollarAndRequestUnion$outboundSchema.parse(
      patchV2WebhooksWebhookIdDollarAndRequestUnion,
    ),
  );
}

/** @internal */
export type PatchV2WebhooksWebhookIdFilterRequest2$Outbound = {
  $and: Array<
    | PatchV2WebhooksWebhookIdDollarAndEqualsRequest$Outbound
    | PatchV2WebhooksWebhookIdDollarAndNotEqualsRequest$Outbound
  >;
};

/** @internal */
export const PatchV2WebhooksWebhookIdFilterRequest2$outboundSchema:
  z.ZodMiniType<
    PatchV2WebhooksWebhookIdFilterRequest2$Outbound,
    PatchV2WebhooksWebhookIdFilterRequest2
  > = z.pipe(
    z.object({
      dollarAnd: z.array(z.union([
        z.lazy(() =>
          PatchV2WebhooksWebhookIdDollarAndEqualsRequest$outboundSchema
        ),
        z.lazy(() =>
          PatchV2WebhooksWebhookIdDollarAndNotEqualsRequest$outboundSchema
        ),
      ])),
    }),
    z.transform((v) => {
      return remap$(v, {
        dollarAnd: "$and",
      });
    }),
  );

export function patchV2WebhooksWebhookIdFilterRequest2ToJSON(
  patchV2WebhooksWebhookIdFilterRequest2:
    PatchV2WebhooksWebhookIdFilterRequest2,
): string {
  return JSON.stringify(
    PatchV2WebhooksWebhookIdFilterRequest2$outboundSchema.parse(
      patchV2WebhooksWebhookIdFilterRequest2,
    ),
  );
}

/** @internal */
export type PatchV2WebhooksWebhookIdDollarOrNotEqualsRequest$Outbound = {
  field: string;
  operator: "not_equals";
  value: string;
};

/** @internal */
export const PatchV2WebhooksWebhookIdDollarOrNotEqualsRequest$outboundSchema:
  z.ZodMiniType<
    PatchV2WebhooksWebhookIdDollarOrNotEqualsRequest$Outbound,
    PatchV2WebhooksWebhookIdDollarOrNotEqualsRequest
  > = z.object({
    field: z.string(),
    operator: z.literal("not_equals"),
    value: z.string(),
  });

export function patchV2WebhooksWebhookIdDollarOrNotEqualsRequestToJSON(
  patchV2WebhooksWebhookIdDollarOrNotEqualsRequest:
    PatchV2WebhooksWebhookIdDollarOrNotEqualsRequest,
): string {
  return JSON.stringify(
    PatchV2WebhooksWebhookIdDollarOrNotEqualsRequest$outboundSchema.parse(
      patchV2WebhooksWebhookIdDollarOrNotEqualsRequest,
    ),
  );
}

/** @internal */
export type PatchV2WebhooksWebhookIdDollarOrEqualsRequest$Outbound = {
  field: string;
  operator: "equals";
  value: string;
};

/** @internal */
export const PatchV2WebhooksWebhookIdDollarOrEqualsRequest$outboundSchema:
  z.ZodMiniType<
    PatchV2WebhooksWebhookIdDollarOrEqualsRequest$Outbound,
    PatchV2WebhooksWebhookIdDollarOrEqualsRequest
  > = z.object({
    field: z.string(),
    operator: z.literal("equals"),
    value: z.string(),
  });

export function patchV2WebhooksWebhookIdDollarOrEqualsRequestToJSON(
  patchV2WebhooksWebhookIdDollarOrEqualsRequest:
    PatchV2WebhooksWebhookIdDollarOrEqualsRequest,
): string {
  return JSON.stringify(
    PatchV2WebhooksWebhookIdDollarOrEqualsRequest$outboundSchema.parse(
      patchV2WebhooksWebhookIdDollarOrEqualsRequest,
    ),
  );
}

/** @internal */
export type PatchV2WebhooksWebhookIdDollarOrRequestUnion$Outbound =
  | PatchV2WebhooksWebhookIdDollarOrEqualsRequest$Outbound
  | PatchV2WebhooksWebhookIdDollarOrNotEqualsRequest$Outbound;

/** @internal */
export const PatchV2WebhooksWebhookIdDollarOrRequestUnion$outboundSchema:
  z.ZodMiniType<
    PatchV2WebhooksWebhookIdDollarOrRequestUnion$Outbound,
    PatchV2WebhooksWebhookIdDollarOrRequestUnion
  > = z.union([
    z.lazy(() => PatchV2WebhooksWebhookIdDollarOrEqualsRequest$outboundSchema),
    z.lazy(() =>
      PatchV2WebhooksWebhookIdDollarOrNotEqualsRequest$outboundSchema
    ),
  ]);

export function patchV2WebhooksWebhookIdDollarOrRequestUnionToJSON(
  patchV2WebhooksWebhookIdDollarOrRequestUnion:
    PatchV2WebhooksWebhookIdDollarOrRequestUnion,
): string {
  return JSON.stringify(
    PatchV2WebhooksWebhookIdDollarOrRequestUnion$outboundSchema.parse(
      patchV2WebhooksWebhookIdDollarOrRequestUnion,
    ),
  );
}

/** @internal */
export type PatchV2WebhooksWebhookIdFilterRequest1$Outbound = {
  $or: Array<
    | PatchV2WebhooksWebhookIdDollarOrEqualsRequest$Outbound
    | PatchV2WebhooksWebhookIdDollarOrNotEqualsRequest$Outbound
  >;
};

/** @internal */
export const PatchV2WebhooksWebhookIdFilterRequest1$outboundSchema:
  z.ZodMiniType<
    PatchV2WebhooksWebhookIdFilterRequest1$Outbound,
    PatchV2WebhooksWebhookIdFilterRequest1
  > = z.pipe(
    z.object({
      dollarOr: z.array(z.union([
        z.lazy(() =>
          PatchV2WebhooksWebhookIdDollarOrEqualsRequest$outboundSchema
        ),
        z.lazy(() =>
          PatchV2WebhooksWebhookIdDollarOrNotEqualsRequest$outboundSchema
        ),
      ])),
    }),
    z.transform((v) => {
      return remap$(v, {
        dollarOr: "$or",
      });
    }),
  );

export function patchV2WebhooksWebhookIdFilterRequest1ToJSON(
  patchV2WebhooksWebhookIdFilterRequest1:
    PatchV2WebhooksWebhookIdFilterRequest1,
): string {
  return JSON.stringify(
    PatchV2WebhooksWebhookIdFilterRequest1$outboundSchema.parse(
      patchV2WebhooksWebhookIdFilterRequest1,
    ),
  );
}

/** @internal */
export type PatchV2WebhooksWebhookIdFilterRequestUnion$Outbound =
  | PatchV2WebhooksWebhookIdFilterRequest1$Outbound
  | PatchV2WebhooksWebhookIdFilterRequest2$Outbound;

/** @internal */
export const PatchV2WebhooksWebhookIdFilterRequestUnion$outboundSchema:
  z.ZodMiniType<
    PatchV2WebhooksWebhookIdFilterRequestUnion$Outbound,
    PatchV2WebhooksWebhookIdFilterRequestUnion
  > = smartUnion([
    z.lazy(() => PatchV2WebhooksWebhookIdFilterRequest1$outboundSchema),
    z.lazy(() => PatchV2WebhooksWebhookIdFilterRequest2$outboundSchema),
  ]);

export function patchV2WebhooksWebhookIdFilterRequestUnionToJSON(
  patchV2WebhooksWebhookIdFilterRequestUnion:
    PatchV2WebhooksWebhookIdFilterRequestUnion,
): string {
  return JSON.stringify(
    PatchV2WebhooksWebhookIdFilterRequestUnion$outboundSchema.parse(
      patchV2WebhooksWebhookIdFilterRequestUnion,
    ),
  );
}

/** @internal */
export type PatchV2WebhooksWebhookIdSubscriptionRequest$Outbound = {
  event_type: string;
  filter:
    | PatchV2WebhooksWebhookIdFilterRequest1$Outbound
    | PatchV2WebhooksWebhookIdFilterRequest2$Outbound
    | null;
};

/** @internal */
export const PatchV2WebhooksWebhookIdSubscriptionRequest$outboundSchema:
  z.ZodMiniType<
    PatchV2WebhooksWebhookIdSubscriptionRequest$Outbound,
    PatchV2WebhooksWebhookIdSubscriptionRequest
  > = z.pipe(
    z.object({
      eventType: PatchV2WebhooksWebhookIdEventTypeRequest$outboundSchema,
      filter: z.nullable(smartUnion([
        z.lazy(() => PatchV2WebhooksWebhookIdFilterRequest1$outboundSchema),
        z.lazy(() => PatchV2WebhooksWebhookIdFilterRequest2$outboundSchema),
      ])),
    }),
    z.transform((v) => {
      return remap$(v, {
        eventType: "event_type",
      });
    }),
  );

export function patchV2WebhooksWebhookIdSubscriptionRequestToJSON(
  patchV2WebhooksWebhookIdSubscriptionRequest:
    PatchV2WebhooksWebhookIdSubscriptionRequest,
): string {
  return JSON.stringify(
    PatchV2WebhooksWebhookIdSubscriptionRequest$outboundSchema.parse(
      patchV2WebhooksWebhookIdSubscriptionRequest,
    ),
  );
}

/** @internal */
export type PatchV2WebhooksWebhookIdDataRequest$Outbound = {
  target_url?: string | undefined;
  subscriptions?:
    | Array<PatchV2WebhooksWebhookIdSubscriptionRequest$Outbound>
    | undefined;
};

/** @internal */
export const PatchV2WebhooksWebhookIdDataRequest$outboundSchema: z.ZodMiniType<
  PatchV2WebhooksWebhookIdDataRequest$Outbound,
  PatchV2WebhooksWebhookIdDataRequest
> = z.pipe(
  z.object({
    targetUrl: z.optional(z.string()),
    subscriptions: z.optional(z.array(z.lazy(() =>
      PatchV2WebhooksWebhookIdSubscriptionRequest$outboundSchema
    ))),
  }),
  z.transform((v) => {
    return remap$(v, {
      targetUrl: "target_url",
    });
  }),
);

export function patchV2WebhooksWebhookIdDataRequestToJSON(
  patchV2WebhooksWebhookIdDataRequest: PatchV2WebhooksWebhookIdDataRequest,
): string {
  return JSON.stringify(
    PatchV2WebhooksWebhookIdDataRequest$outboundSchema.parse(
      patchV2WebhooksWebhookIdDataRequest,
    ),
  );
}

/** @internal */
export type PatchV2WebhooksWebhookIdRequestBody$Outbound = {
  data: PatchV2WebhooksWebhookIdDataRequest$Outbound;
};

/** @internal */
export const PatchV2WebhooksWebhookIdRequestBody$outboundSchema: z.ZodMiniType<
  PatchV2WebhooksWebhookIdRequestBody$Outbound,
  PatchV2WebhooksWebhookIdRequestBody
> = z.object({
  data: z.lazy(() => PatchV2WebhooksWebhookIdDataRequest$outboundSchema),
});

export function patchV2WebhooksWebhookIdRequestBodyToJSON(
  patchV2WebhooksWebhookIdRequestBody: PatchV2WebhooksWebhookIdRequestBody,
): string {
  return JSON.stringify(
    PatchV2WebhooksWebhookIdRequestBody$outboundSchema.parse(
      patchV2WebhooksWebhookIdRequestBody,
    ),
  );
}

/** @internal */
export type PatchV2WebhooksWebhookIdRequest$Outbound = {
  webhook_id: string;
  body: PatchV2WebhooksWebhookIdRequestBody$Outbound;
};

/** @internal */
export const PatchV2WebhooksWebhookIdRequest$outboundSchema: z.ZodMiniType<
  PatchV2WebhooksWebhookIdRequest$Outbound,
  PatchV2WebhooksWebhookIdRequest
> = z.pipe(
  z.object({
    webhookId: z.string(),
    body: z.lazy(() => PatchV2WebhooksWebhookIdRequestBody$outboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      webhookId: "webhook_id",
    });
  }),
);

export function patchV2WebhooksWebhookIdRequestToJSON(
  patchV2WebhooksWebhookIdRequest: PatchV2WebhooksWebhookIdRequest,
): string {
  return JSON.stringify(
    PatchV2WebhooksWebhookIdRequest$outboundSchema.parse(
      patchV2WebhooksWebhookIdRequest,
    ),
  );
}

/** @internal */
export const PatchV2WebhooksWebhookIdType$inboundSchema: z.ZodMiniEnum<
  typeof PatchV2WebhooksWebhookIdType
> = z.enum(PatchV2WebhooksWebhookIdType);

/** @internal */
export const PatchV2WebhooksWebhookIdCode$inboundSchema: z.ZodMiniEnum<
  typeof PatchV2WebhooksWebhookIdCode
> = z.enum(PatchV2WebhooksWebhookIdCode);

/** @internal */
export const PatchV2WebhooksWebhookIdEventTypeResponse$inboundSchema:
  z.ZodMiniType<PatchV2WebhooksWebhookIdEventTypeResponse, unknown> = openEnums
    .inboundSchema(PatchV2WebhooksWebhookIdEventTypeResponse);

/** @internal */
export const PatchV2WebhooksWebhookIdDollarAndNotEqualsResponse$inboundSchema:
  z.ZodMiniType<PatchV2WebhooksWebhookIdDollarAndNotEqualsResponse, unknown> = z
    .object({
      field: types.string(),
      operator: types.literal("not_equals"),
      value: types.string(),
    });

export function patchV2WebhooksWebhookIdDollarAndNotEqualsResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PatchV2WebhooksWebhookIdDollarAndNotEqualsResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PatchV2WebhooksWebhookIdDollarAndNotEqualsResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PatchV2WebhooksWebhookIdDollarAndNotEqualsResponse' from JSON`,
  );
}

/** @internal */
export const PatchV2WebhooksWebhookIdDollarAndEqualsResponse$inboundSchema:
  z.ZodMiniType<PatchV2WebhooksWebhookIdDollarAndEqualsResponse, unknown> = z
    .object({
      field: types.string(),
      operator: types.literal("equals"),
      value: types.string(),
    });

export function patchV2WebhooksWebhookIdDollarAndEqualsResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PatchV2WebhooksWebhookIdDollarAndEqualsResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PatchV2WebhooksWebhookIdDollarAndEqualsResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PatchV2WebhooksWebhookIdDollarAndEqualsResponse' from JSON`,
  );
}

/** @internal */
export const PatchV2WebhooksWebhookIdDollarAndResponseUnion$inboundSchema:
  z.ZodMiniType<PatchV2WebhooksWebhookIdDollarAndResponseUnion, unknown> =
    discriminatedUnion("operator", {
      equals: z.lazy(() =>
        PatchV2WebhooksWebhookIdDollarAndEqualsResponse$inboundSchema
      ),
      not_equals: z.lazy(() =>
        PatchV2WebhooksWebhookIdDollarAndNotEqualsResponse$inboundSchema
      ),
    });

export function patchV2WebhooksWebhookIdDollarAndResponseUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  PatchV2WebhooksWebhookIdDollarAndResponseUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PatchV2WebhooksWebhookIdDollarAndResponseUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PatchV2WebhooksWebhookIdDollarAndResponseUnion' from JSON`,
  );
}

/** @internal */
export const PatchV2WebhooksWebhookIdFilterResponse2$inboundSchema:
  z.ZodMiniType<PatchV2WebhooksWebhookIdFilterResponse2, unknown> = z.pipe(
    z.object({
      $and: z.array(discriminatedUnion("operator", {
        equals: z.lazy(() =>
          PatchV2WebhooksWebhookIdDollarAndEqualsResponse$inboundSchema
        ),
        not_equals: z.lazy(() =>
          PatchV2WebhooksWebhookIdDollarAndNotEqualsResponse$inboundSchema
        ),
      })),
    }),
    z.transform((v) => {
      return remap$(v, {
        "$and": "dollarAnd",
      });
    }),
  );

export function patchV2WebhooksWebhookIdFilterResponse2FromJSON(
  jsonString: string,
): SafeParseResult<
  PatchV2WebhooksWebhookIdFilterResponse2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PatchV2WebhooksWebhookIdFilterResponse2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PatchV2WebhooksWebhookIdFilterResponse2' from JSON`,
  );
}

/** @internal */
export const PatchV2WebhooksWebhookIdDollarOrNotEqualsResponse$inboundSchema:
  z.ZodMiniType<PatchV2WebhooksWebhookIdDollarOrNotEqualsResponse, unknown> = z
    .object({
      field: types.string(),
      operator: types.literal("not_equals"),
      value: types.string(),
    });

export function patchV2WebhooksWebhookIdDollarOrNotEqualsResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PatchV2WebhooksWebhookIdDollarOrNotEqualsResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PatchV2WebhooksWebhookIdDollarOrNotEqualsResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PatchV2WebhooksWebhookIdDollarOrNotEqualsResponse' from JSON`,
  );
}

/** @internal */
export const PatchV2WebhooksWebhookIdDollarOrEqualsResponse$inboundSchema:
  z.ZodMiniType<PatchV2WebhooksWebhookIdDollarOrEqualsResponse, unknown> = z
    .object({
      field: types.string(),
      operator: types.literal("equals"),
      value: types.string(),
    });

export function patchV2WebhooksWebhookIdDollarOrEqualsResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PatchV2WebhooksWebhookIdDollarOrEqualsResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PatchV2WebhooksWebhookIdDollarOrEqualsResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PatchV2WebhooksWebhookIdDollarOrEqualsResponse' from JSON`,
  );
}

/** @internal */
export const PatchV2WebhooksWebhookIdDollarOrResponseUnion$inboundSchema:
  z.ZodMiniType<PatchV2WebhooksWebhookIdDollarOrResponseUnion, unknown> =
    discriminatedUnion("operator", {
      equals: z.lazy(() =>
        PatchV2WebhooksWebhookIdDollarOrEqualsResponse$inboundSchema
      ),
      not_equals: z.lazy(() =>
        PatchV2WebhooksWebhookIdDollarOrNotEqualsResponse$inboundSchema
      ),
    });

export function patchV2WebhooksWebhookIdDollarOrResponseUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  PatchV2WebhooksWebhookIdDollarOrResponseUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PatchV2WebhooksWebhookIdDollarOrResponseUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PatchV2WebhooksWebhookIdDollarOrResponseUnion' from JSON`,
  );
}

/** @internal */
export const PatchV2WebhooksWebhookIdFilterResponse1$inboundSchema:
  z.ZodMiniType<PatchV2WebhooksWebhookIdFilterResponse1, unknown> = z.pipe(
    z.object({
      $or: z.array(discriminatedUnion("operator", {
        equals: z.lazy(() =>
          PatchV2WebhooksWebhookIdDollarOrEqualsResponse$inboundSchema
        ),
        not_equals: z.lazy(() =>
          PatchV2WebhooksWebhookIdDollarOrNotEqualsResponse$inboundSchema
        ),
      })),
    }),
    z.transform((v) => {
      return remap$(v, {
        "$or": "dollarOr",
      });
    }),
  );

export function patchV2WebhooksWebhookIdFilterResponse1FromJSON(
  jsonString: string,
): SafeParseResult<
  PatchV2WebhooksWebhookIdFilterResponse1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PatchV2WebhooksWebhookIdFilterResponse1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PatchV2WebhooksWebhookIdFilterResponse1' from JSON`,
  );
}

/** @internal */
export const PatchV2WebhooksWebhookIdFilterResponseUnion$inboundSchema:
  z.ZodMiniType<PatchV2WebhooksWebhookIdFilterResponseUnion, unknown> =
    smartUnion([
      z.lazy(() => PatchV2WebhooksWebhookIdFilterResponse1$inboundSchema),
      z.lazy(() => PatchV2WebhooksWebhookIdFilterResponse2$inboundSchema),
    ]);

export function patchV2WebhooksWebhookIdFilterResponseUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  PatchV2WebhooksWebhookIdFilterResponseUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PatchV2WebhooksWebhookIdFilterResponseUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PatchV2WebhooksWebhookIdFilterResponseUnion' from JSON`,
  );
}

/** @internal */
export const PatchV2WebhooksWebhookIdSubscriptionResponse$inboundSchema:
  z.ZodMiniType<PatchV2WebhooksWebhookIdSubscriptionResponse, unknown> = z.pipe(
    z.object({
      event_type: PatchV2WebhooksWebhookIdEventTypeResponse$inboundSchema,
      filter: types.nullable(smartUnion([
        z.lazy(() => PatchV2WebhooksWebhookIdFilterResponse1$inboundSchema),
        z.lazy(() =>
          PatchV2WebhooksWebhookIdFilterResponse2$inboundSchema
        ),
      ])),
    }),
    z.transform((v) => {
      return remap$(v, {
        "event_type": "eventType",
      });
    }),
  );

export function patchV2WebhooksWebhookIdSubscriptionResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PatchV2WebhooksWebhookIdSubscriptionResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PatchV2WebhooksWebhookIdSubscriptionResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PatchV2WebhooksWebhookIdSubscriptionResponse' from JSON`,
  );
}

/** @internal */
export const PatchV2WebhooksWebhookIdId$inboundSchema: z.ZodMiniType<
  PatchV2WebhooksWebhookIdId,
  unknown
> = z.pipe(
  z.object({
    workspace_id: types.string(),
    webhook_id: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "workspace_id": "workspaceId",
      "webhook_id": "webhookId",
    });
  }),
);

export function patchV2WebhooksWebhookIdIdFromJSON(
  jsonString: string,
): SafeParseResult<PatchV2WebhooksWebhookIdId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PatchV2WebhooksWebhookIdId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PatchV2WebhooksWebhookIdId' from JSON`,
  );
}

/** @internal */
export const PatchV2WebhooksWebhookIdStatus$inboundSchema: z.ZodMiniType<
  PatchV2WebhooksWebhookIdStatus,
  unknown
> = openEnums.inboundSchema(PatchV2WebhooksWebhookIdStatus);

/** @internal */
export const PatchV2WebhooksWebhookIdDataResponse$inboundSchema: z.ZodMiniType<
  PatchV2WebhooksWebhookIdDataResponse,
  unknown
> = z.pipe(
  z.object({
    target_url: types.string(),
    subscriptions: z.array(
      z.lazy(() => PatchV2WebhooksWebhookIdSubscriptionResponse$inboundSchema),
    ),
    id: z.lazy(() => PatchV2WebhooksWebhookIdId$inboundSchema),
    status: PatchV2WebhooksWebhookIdStatus$inboundSchema,
    created_at: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "target_url": "targetUrl",
      "created_at": "createdAt",
    });
  }),
);

export function patchV2WebhooksWebhookIdDataResponseFromJSON(
  jsonString: string,
): SafeParseResult<PatchV2WebhooksWebhookIdDataResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PatchV2WebhooksWebhookIdDataResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PatchV2WebhooksWebhookIdDataResponse' from JSON`,
  );
}

/** @internal */
export const PatchV2WebhooksWebhookIdResponse$inboundSchema: z.ZodMiniType<
  PatchV2WebhooksWebhookIdResponse,
  unknown
> = z.object({
  data: z.lazy(() => PatchV2WebhooksWebhookIdDataResponse$inboundSchema),
});

export function patchV2WebhooksWebhookIdResponseFromJSON(
  jsonString: string,
): SafeParseResult<PatchV2WebhooksWebhookIdResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PatchV2WebhooksWebhookIdResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PatchV2WebhooksWebhookIdResponse' from JSON`,
  );
}
