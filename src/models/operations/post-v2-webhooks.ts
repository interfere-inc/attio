/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as discriminatedUnionTypes from "../../types/discriminated-union.js";
import { discriminatedUnion } from "../../types/discriminated-union.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { smartUnion } from "../../types/smart-union.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * Type of event the webhook is subscribed to.
 */
export const PostV2WebhooksEventTypeRequest = {
  CallRecordingCreated: "call-recording.created",
  CommentCreated: "comment.created",
  CommentResolved: "comment.resolved",
  CommentUnresolved: "comment.unresolved",
  CommentDeleted: "comment.deleted",
  ListCreated: "list.created",
  ListUpdated: "list.updated",
  ListDeleted: "list.deleted",
  ListAttributeCreated: "list-attribute.created",
  ListAttributeUpdated: "list-attribute.updated",
  ListEntryCreated: "list-entry.created",
  ListEntryUpdated: "list-entry.updated",
  ListEntryDeleted: "list-entry.deleted",
  ObjectAttributeCreated: "object-attribute.created",
  ObjectAttributeUpdated: "object-attribute.updated",
  NoteCreated: "note.created",
  NoteContentUpdated: "note-content.updated",
  NoteUpdated: "note.updated",
  NoteDeleted: "note.deleted",
  RecordCreated: "record.created",
  RecordMerged: "record.merged",
  RecordUpdated: "record.updated",
  RecordDeleted: "record.deleted",
  TaskCreated: "task.created",
  TaskUpdated: "task.updated",
  TaskDeleted: "task.deleted",
  WorkspaceMemberCreated: "workspace-member.created",
} as const;
/**
 * Type of event the webhook is subscribed to.
 */
export type PostV2WebhooksEventTypeRequest = ClosedEnum<
  typeof PostV2WebhooksEventTypeRequest
>;

export type PostV2WebhooksDollarAndNotEqualsRequest = {
  field: string;
  operator: "not_equals";
  value: string;
};

export type PostV2WebhooksDollarAndEqualsRequest = {
  field: string;
  operator: "equals";
  value: string;
};

export type PostV2WebhooksDollarAndRequestUnion =
  | PostV2WebhooksDollarAndEqualsRequest
  | PostV2WebhooksDollarAndNotEqualsRequest;

export type PostV2WebhooksFilterRequest2 = {
  dollarAnd: Array<
    | PostV2WebhooksDollarAndEqualsRequest
    | PostV2WebhooksDollarAndNotEqualsRequest
  >;
};

export type PostV2WebhooksDollarOrNotEqualsRequest = {
  field: string;
  operator: "not_equals";
  value: string;
};

export type PostV2WebhooksDollarOrEqualsRequest = {
  field: string;
  operator: "equals";
  value: string;
};

export type PostV2WebhooksDollarOrRequestUnion =
  | PostV2WebhooksDollarOrEqualsRequest
  | PostV2WebhooksDollarOrNotEqualsRequest;

export type PostV2WebhooksFilterRequest1 = {
  dollarOr: Array<
    PostV2WebhooksDollarOrEqualsRequest | PostV2WebhooksDollarOrNotEqualsRequest
  >;
};

/**
 * Filters to determine whether the webhook event should be sent. If null, the filter always passes.
 */
export type PostV2WebhooksFilterRequestUnion =
  | PostV2WebhooksFilterRequest1
  | PostV2WebhooksFilterRequest2;

export type PostV2WebhooksSubscriptionRequest = {
  /**
   * Type of event the webhook is subscribed to.
   */
  eventType: PostV2WebhooksEventTypeRequest;
  /**
   * Filters to determine whether the webhook event should be sent. If null, the filter always passes.
   */
  filter: PostV2WebhooksFilterRequest1 | PostV2WebhooksFilterRequest2 | null;
};

export type PostV2WebhooksDataRequest = {
  /**
   * URL where the webhook events will be delivered to.
   */
  targetUrl: string;
  /**
   * One or more events the webhook is subscribed to.
   */
  subscriptions: Array<PostV2WebhooksSubscriptionRequest>;
};

export type PostV2WebhooksRequest = {
  data: PostV2WebhooksDataRequest;
};

export const PostV2WebhooksType = {
  InvalidRequestError: "invalid_request_error",
} as const;
export type PostV2WebhooksType = ClosedEnum<typeof PostV2WebhooksType>;

export const PostV2WebhooksCode = {
  ValidationType: "validation_type",
} as const;
export type PostV2WebhooksCode = ClosedEnum<typeof PostV2WebhooksCode>;

/**
 * Type of event the webhook is subscribed to.
 */
export const PostV2WebhooksEventTypeResponse = {
  CallRecordingCreated: "call-recording.created",
  CommentCreated: "comment.created",
  CommentResolved: "comment.resolved",
  CommentUnresolved: "comment.unresolved",
  CommentDeleted: "comment.deleted",
  ListCreated: "list.created",
  ListUpdated: "list.updated",
  ListDeleted: "list.deleted",
  ListAttributeCreated: "list-attribute.created",
  ListAttributeUpdated: "list-attribute.updated",
  ListEntryCreated: "list-entry.created",
  ListEntryUpdated: "list-entry.updated",
  ListEntryDeleted: "list-entry.deleted",
  ObjectAttributeCreated: "object-attribute.created",
  ObjectAttributeUpdated: "object-attribute.updated",
  NoteCreated: "note.created",
  NoteContentUpdated: "note-content.updated",
  NoteUpdated: "note.updated",
  NoteDeleted: "note.deleted",
  RecordCreated: "record.created",
  RecordMerged: "record.merged",
  RecordUpdated: "record.updated",
  RecordDeleted: "record.deleted",
  TaskCreated: "task.created",
  TaskUpdated: "task.updated",
  TaskDeleted: "task.deleted",
  WorkspaceMemberCreated: "workspace-member.created",
} as const;
/**
 * Type of event the webhook is subscribed to.
 */
export type PostV2WebhooksEventTypeResponse = OpenEnum<
  typeof PostV2WebhooksEventTypeResponse
>;

export type PostV2WebhooksDollarAndNotEqualsResponse = {
  field: string;
  operator: "not_equals";
  value: string;
};

export type PostV2WebhooksDollarAndEqualsResponse = {
  field: string;
  operator: "equals";
  value: string;
};

export type PostV2WebhooksDollarAndResponseUnion =
  | PostV2WebhooksDollarAndEqualsResponse
  | PostV2WebhooksDollarAndNotEqualsResponse
  | discriminatedUnionTypes.Unknown<"operator">;

export type PostV2WebhooksFilterResponse2 = {
  dollarAnd: Array<
    | PostV2WebhooksDollarAndEqualsResponse
    | PostV2WebhooksDollarAndNotEqualsResponse
    | discriminatedUnionTypes.Unknown<"operator">
  >;
};

export type PostV2WebhooksDollarOrNotEqualsResponse = {
  field: string;
  operator: "not_equals";
  value: string;
};

export type PostV2WebhooksDollarOrEqualsResponse = {
  field: string;
  operator: "equals";
  value: string;
};

export type PostV2WebhooksDollarOrResponseUnion =
  | PostV2WebhooksDollarOrEqualsResponse
  | PostV2WebhooksDollarOrNotEqualsResponse
  | discriminatedUnionTypes.Unknown<"operator">;

export type PostV2WebhooksFilterResponse1 = {
  dollarOr: Array<
    | PostV2WebhooksDollarOrEqualsResponse
    | PostV2WebhooksDollarOrNotEqualsResponse
    | discriminatedUnionTypes.Unknown<"operator">
  >;
};

/**
 * Filters to determine whether the webhook event should be sent. If null, the filter always passes.
 */
export type PostV2WebhooksFilterResponseUnion =
  | PostV2WebhooksFilterResponse1
  | PostV2WebhooksFilterResponse2;

export type PostV2WebhooksSubscriptionResponse = {
  /**
   * Type of event the webhook is subscribed to.
   */
  eventType: PostV2WebhooksEventTypeResponse;
  /**
   * Filters to determine whether the webhook event should be sent. If null, the filter always passes.
   */
  filter: PostV2WebhooksFilterResponse1 | PostV2WebhooksFilterResponse2 | null;
};

export type PostV2WebhooksId = {
  /**
   * The ID of the workspace the webhook belongs to.
   */
  workspaceId: string;
  /**
   * The ID of the webhook.
   */
  webhookId: string;
};

/**
 * The state of the webhook. Webhooks marked as active and degraded will receive events, inactive ones will not. If a webhook remains in the degraded state for 7 days, it will be marked inactive.
 */
export const PostV2WebhooksStatus = {
  Active: "active",
  Degraded: "degraded",
  Inactive: "inactive",
} as const;
/**
 * The state of the webhook. Webhooks marked as active and degraded will receive events, inactive ones will not. If a webhook remains in the degraded state for 7 days, it will be marked inactive.
 */
export type PostV2WebhooksStatus = OpenEnum<typeof PostV2WebhooksStatus>;

export type PostV2WebhooksDataResponse = {
  /**
   * URL where the webhook events will be delivered to.
   */
  targetUrl: string;
  /**
   * One or more events the webhook is subscribed to.
   */
  subscriptions: Array<PostV2WebhooksSubscriptionResponse>;
  id: PostV2WebhooksId;
  /**
   * The state of the webhook. Webhooks marked as active and degraded will receive events, inactive ones will not. If a webhook remains in the degraded state for 7 days, it will be marked inactive.
   */
  status: PostV2WebhooksStatus;
  /**
   * When the webhook was created.
   */
  createdAt: string;
  /**
   * The key which is used to sign the webhook events. This is only shown when setting up the webhook initially.
   */
  secret: string;
};

/**
 * Success
 */
export type PostV2WebhooksResponse = {
  data: PostV2WebhooksDataResponse;
};

/** @internal */
export const PostV2WebhooksEventTypeRequest$outboundSchema: z.ZodMiniEnum<
  typeof PostV2WebhooksEventTypeRequest
> = z.enum(PostV2WebhooksEventTypeRequest);

/** @internal */
export type PostV2WebhooksDollarAndNotEqualsRequest$Outbound = {
  field: string;
  operator: "not_equals";
  value: string;
};

/** @internal */
export const PostV2WebhooksDollarAndNotEqualsRequest$outboundSchema:
  z.ZodMiniType<
    PostV2WebhooksDollarAndNotEqualsRequest$Outbound,
    PostV2WebhooksDollarAndNotEqualsRequest
  > = z.object({
    field: z.string(),
    operator: z.literal("not_equals"),
    value: z.string(),
  });

export function postV2WebhooksDollarAndNotEqualsRequestToJSON(
  postV2WebhooksDollarAndNotEqualsRequest:
    PostV2WebhooksDollarAndNotEqualsRequest,
): string {
  return JSON.stringify(
    PostV2WebhooksDollarAndNotEqualsRequest$outboundSchema.parse(
      postV2WebhooksDollarAndNotEqualsRequest,
    ),
  );
}

/** @internal */
export type PostV2WebhooksDollarAndEqualsRequest$Outbound = {
  field: string;
  operator: "equals";
  value: string;
};

/** @internal */
export const PostV2WebhooksDollarAndEqualsRequest$outboundSchema: z.ZodMiniType<
  PostV2WebhooksDollarAndEqualsRequest$Outbound,
  PostV2WebhooksDollarAndEqualsRequest
> = z.object({
  field: z.string(),
  operator: z.literal("equals"),
  value: z.string(),
});

export function postV2WebhooksDollarAndEqualsRequestToJSON(
  postV2WebhooksDollarAndEqualsRequest: PostV2WebhooksDollarAndEqualsRequest,
): string {
  return JSON.stringify(
    PostV2WebhooksDollarAndEqualsRequest$outboundSchema.parse(
      postV2WebhooksDollarAndEqualsRequest,
    ),
  );
}

/** @internal */
export type PostV2WebhooksDollarAndRequestUnion$Outbound =
  | PostV2WebhooksDollarAndEqualsRequest$Outbound
  | PostV2WebhooksDollarAndNotEqualsRequest$Outbound;

/** @internal */
export const PostV2WebhooksDollarAndRequestUnion$outboundSchema: z.ZodMiniType<
  PostV2WebhooksDollarAndRequestUnion$Outbound,
  PostV2WebhooksDollarAndRequestUnion
> = z.union([
  z.lazy(() => PostV2WebhooksDollarAndEqualsRequest$outboundSchema),
  z.lazy(() => PostV2WebhooksDollarAndNotEqualsRequest$outboundSchema),
]);

export function postV2WebhooksDollarAndRequestUnionToJSON(
  postV2WebhooksDollarAndRequestUnion: PostV2WebhooksDollarAndRequestUnion,
): string {
  return JSON.stringify(
    PostV2WebhooksDollarAndRequestUnion$outboundSchema.parse(
      postV2WebhooksDollarAndRequestUnion,
    ),
  );
}

/** @internal */
export type PostV2WebhooksFilterRequest2$Outbound = {
  $and: Array<
    | PostV2WebhooksDollarAndEqualsRequest$Outbound
    | PostV2WebhooksDollarAndNotEqualsRequest$Outbound
  >;
};

/** @internal */
export const PostV2WebhooksFilterRequest2$outboundSchema: z.ZodMiniType<
  PostV2WebhooksFilterRequest2$Outbound,
  PostV2WebhooksFilterRequest2
> = z.pipe(
  z.object({
    dollarAnd: z.array(z.union([
      z.lazy(() => PostV2WebhooksDollarAndEqualsRequest$outboundSchema),
      z.lazy(() => PostV2WebhooksDollarAndNotEqualsRequest$outboundSchema),
    ])),
  }),
  z.transform((v) => {
    return remap$(v, {
      dollarAnd: "$and",
    });
  }),
);

export function postV2WebhooksFilterRequest2ToJSON(
  postV2WebhooksFilterRequest2: PostV2WebhooksFilterRequest2,
): string {
  return JSON.stringify(
    PostV2WebhooksFilterRequest2$outboundSchema.parse(
      postV2WebhooksFilterRequest2,
    ),
  );
}

/** @internal */
export type PostV2WebhooksDollarOrNotEqualsRequest$Outbound = {
  field: string;
  operator: "not_equals";
  value: string;
};

/** @internal */
export const PostV2WebhooksDollarOrNotEqualsRequest$outboundSchema:
  z.ZodMiniType<
    PostV2WebhooksDollarOrNotEqualsRequest$Outbound,
    PostV2WebhooksDollarOrNotEqualsRequest
  > = z.object({
    field: z.string(),
    operator: z.literal("not_equals"),
    value: z.string(),
  });

export function postV2WebhooksDollarOrNotEqualsRequestToJSON(
  postV2WebhooksDollarOrNotEqualsRequest:
    PostV2WebhooksDollarOrNotEqualsRequest,
): string {
  return JSON.stringify(
    PostV2WebhooksDollarOrNotEqualsRequest$outboundSchema.parse(
      postV2WebhooksDollarOrNotEqualsRequest,
    ),
  );
}

/** @internal */
export type PostV2WebhooksDollarOrEqualsRequest$Outbound = {
  field: string;
  operator: "equals";
  value: string;
};

/** @internal */
export const PostV2WebhooksDollarOrEqualsRequest$outboundSchema: z.ZodMiniType<
  PostV2WebhooksDollarOrEqualsRequest$Outbound,
  PostV2WebhooksDollarOrEqualsRequest
> = z.object({
  field: z.string(),
  operator: z.literal("equals"),
  value: z.string(),
});

export function postV2WebhooksDollarOrEqualsRequestToJSON(
  postV2WebhooksDollarOrEqualsRequest: PostV2WebhooksDollarOrEqualsRequest,
): string {
  return JSON.stringify(
    PostV2WebhooksDollarOrEqualsRequest$outboundSchema.parse(
      postV2WebhooksDollarOrEqualsRequest,
    ),
  );
}

/** @internal */
export type PostV2WebhooksDollarOrRequestUnion$Outbound =
  | PostV2WebhooksDollarOrEqualsRequest$Outbound
  | PostV2WebhooksDollarOrNotEqualsRequest$Outbound;

/** @internal */
export const PostV2WebhooksDollarOrRequestUnion$outboundSchema: z.ZodMiniType<
  PostV2WebhooksDollarOrRequestUnion$Outbound,
  PostV2WebhooksDollarOrRequestUnion
> = z.union([
  z.lazy(() => PostV2WebhooksDollarOrEqualsRequest$outboundSchema),
  z.lazy(() => PostV2WebhooksDollarOrNotEqualsRequest$outboundSchema),
]);

export function postV2WebhooksDollarOrRequestUnionToJSON(
  postV2WebhooksDollarOrRequestUnion: PostV2WebhooksDollarOrRequestUnion,
): string {
  return JSON.stringify(
    PostV2WebhooksDollarOrRequestUnion$outboundSchema.parse(
      postV2WebhooksDollarOrRequestUnion,
    ),
  );
}

/** @internal */
export type PostV2WebhooksFilterRequest1$Outbound = {
  $or: Array<
    | PostV2WebhooksDollarOrEqualsRequest$Outbound
    | PostV2WebhooksDollarOrNotEqualsRequest$Outbound
  >;
};

/** @internal */
export const PostV2WebhooksFilterRequest1$outboundSchema: z.ZodMiniType<
  PostV2WebhooksFilterRequest1$Outbound,
  PostV2WebhooksFilterRequest1
> = z.pipe(
  z.object({
    dollarOr: z.array(z.union([
      z.lazy(() => PostV2WebhooksDollarOrEqualsRequest$outboundSchema),
      z.lazy(() => PostV2WebhooksDollarOrNotEqualsRequest$outboundSchema),
    ])),
  }),
  z.transform((v) => {
    return remap$(v, {
      dollarOr: "$or",
    });
  }),
);

export function postV2WebhooksFilterRequest1ToJSON(
  postV2WebhooksFilterRequest1: PostV2WebhooksFilterRequest1,
): string {
  return JSON.stringify(
    PostV2WebhooksFilterRequest1$outboundSchema.parse(
      postV2WebhooksFilterRequest1,
    ),
  );
}

/** @internal */
export type PostV2WebhooksFilterRequestUnion$Outbound =
  | PostV2WebhooksFilterRequest1$Outbound
  | PostV2WebhooksFilterRequest2$Outbound;

/** @internal */
export const PostV2WebhooksFilterRequestUnion$outboundSchema: z.ZodMiniType<
  PostV2WebhooksFilterRequestUnion$Outbound,
  PostV2WebhooksFilterRequestUnion
> = smartUnion([
  z.lazy(() => PostV2WebhooksFilterRequest1$outboundSchema),
  z.lazy(() => PostV2WebhooksFilterRequest2$outboundSchema),
]);

export function postV2WebhooksFilterRequestUnionToJSON(
  postV2WebhooksFilterRequestUnion: PostV2WebhooksFilterRequestUnion,
): string {
  return JSON.stringify(
    PostV2WebhooksFilterRequestUnion$outboundSchema.parse(
      postV2WebhooksFilterRequestUnion,
    ),
  );
}

/** @internal */
export type PostV2WebhooksSubscriptionRequest$Outbound = {
  event_type: string;
  filter:
    | PostV2WebhooksFilterRequest1$Outbound
    | PostV2WebhooksFilterRequest2$Outbound
    | null;
};

/** @internal */
export const PostV2WebhooksSubscriptionRequest$outboundSchema: z.ZodMiniType<
  PostV2WebhooksSubscriptionRequest$Outbound,
  PostV2WebhooksSubscriptionRequest
> = z.pipe(
  z.object({
    eventType: PostV2WebhooksEventTypeRequest$outboundSchema,
    filter: z.nullable(smartUnion([
      z.lazy(() => PostV2WebhooksFilterRequest1$outboundSchema),
      z.lazy(() => PostV2WebhooksFilterRequest2$outboundSchema),
    ])),
  }),
  z.transform((v) => {
    return remap$(v, {
      eventType: "event_type",
    });
  }),
);

export function postV2WebhooksSubscriptionRequestToJSON(
  postV2WebhooksSubscriptionRequest: PostV2WebhooksSubscriptionRequest,
): string {
  return JSON.stringify(
    PostV2WebhooksSubscriptionRequest$outboundSchema.parse(
      postV2WebhooksSubscriptionRequest,
    ),
  );
}

/** @internal */
export type PostV2WebhooksDataRequest$Outbound = {
  target_url: string;
  subscriptions: Array<PostV2WebhooksSubscriptionRequest$Outbound>;
};

/** @internal */
export const PostV2WebhooksDataRequest$outboundSchema: z.ZodMiniType<
  PostV2WebhooksDataRequest$Outbound,
  PostV2WebhooksDataRequest
> = z.pipe(
  z.object({
    targetUrl: z.string(),
    subscriptions: z.array(
      z.lazy(() => PostV2WebhooksSubscriptionRequest$outboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      targetUrl: "target_url",
    });
  }),
);

export function postV2WebhooksDataRequestToJSON(
  postV2WebhooksDataRequest: PostV2WebhooksDataRequest,
): string {
  return JSON.stringify(
    PostV2WebhooksDataRequest$outboundSchema.parse(postV2WebhooksDataRequest),
  );
}

/** @internal */
export type PostV2WebhooksRequest$Outbound = {
  data: PostV2WebhooksDataRequest$Outbound;
};

/** @internal */
export const PostV2WebhooksRequest$outboundSchema: z.ZodMiniType<
  PostV2WebhooksRequest$Outbound,
  PostV2WebhooksRequest
> = z.object({
  data: z.lazy(() => PostV2WebhooksDataRequest$outboundSchema),
});

export function postV2WebhooksRequestToJSON(
  postV2WebhooksRequest: PostV2WebhooksRequest,
): string {
  return JSON.stringify(
    PostV2WebhooksRequest$outboundSchema.parse(postV2WebhooksRequest),
  );
}

/** @internal */
export const PostV2WebhooksType$inboundSchema: z.ZodMiniEnum<
  typeof PostV2WebhooksType
> = z.enum(PostV2WebhooksType);

/** @internal */
export const PostV2WebhooksCode$inboundSchema: z.ZodMiniEnum<
  typeof PostV2WebhooksCode
> = z.enum(PostV2WebhooksCode);

/** @internal */
export const PostV2WebhooksEventTypeResponse$inboundSchema: z.ZodMiniType<
  PostV2WebhooksEventTypeResponse,
  unknown
> = openEnums.inboundSchema(PostV2WebhooksEventTypeResponse);

/** @internal */
export const PostV2WebhooksDollarAndNotEqualsResponse$inboundSchema:
  z.ZodMiniType<PostV2WebhooksDollarAndNotEqualsResponse, unknown> = z.object({
    field: types.string(),
    operator: types.literal("not_equals"),
    value: types.string(),
  });

export function postV2WebhooksDollarAndNotEqualsResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV2WebhooksDollarAndNotEqualsResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2WebhooksDollarAndNotEqualsResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV2WebhooksDollarAndNotEqualsResponse' from JSON`,
  );
}

/** @internal */
export const PostV2WebhooksDollarAndEqualsResponse$inboundSchema: z.ZodMiniType<
  PostV2WebhooksDollarAndEqualsResponse,
  unknown
> = z.object({
  field: types.string(),
  operator: types.literal("equals"),
  value: types.string(),
});

export function postV2WebhooksDollarAndEqualsResponseFromJSON(
  jsonString: string,
): SafeParseResult<PostV2WebhooksDollarAndEqualsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2WebhooksDollarAndEqualsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2WebhooksDollarAndEqualsResponse' from JSON`,
  );
}

/** @internal */
export const PostV2WebhooksDollarAndResponseUnion$inboundSchema: z.ZodMiniType<
  PostV2WebhooksDollarAndResponseUnion,
  unknown
> = discriminatedUnion("operator", {
  equals: z.lazy(() => PostV2WebhooksDollarAndEqualsResponse$inboundSchema),
  not_equals: z.lazy(() =>
    PostV2WebhooksDollarAndNotEqualsResponse$inboundSchema
  ),
});

export function postV2WebhooksDollarAndResponseUnionFromJSON(
  jsonString: string,
): SafeParseResult<PostV2WebhooksDollarAndResponseUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2WebhooksDollarAndResponseUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2WebhooksDollarAndResponseUnion' from JSON`,
  );
}

/** @internal */
export const PostV2WebhooksFilterResponse2$inboundSchema: z.ZodMiniType<
  PostV2WebhooksFilterResponse2,
  unknown
> = z.pipe(
  z.object({
    $and: z.array(discriminatedUnion("operator", {
      equals: z.lazy(() => PostV2WebhooksDollarAndEqualsResponse$inboundSchema),
      not_equals: z.lazy(() =>
        PostV2WebhooksDollarAndNotEqualsResponse$inboundSchema
      ),
    })),
  }),
  z.transform((v) => {
    return remap$(v, {
      "$and": "dollarAnd",
    });
  }),
);

export function postV2WebhooksFilterResponse2FromJSON(
  jsonString: string,
): SafeParseResult<PostV2WebhooksFilterResponse2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostV2WebhooksFilterResponse2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2WebhooksFilterResponse2' from JSON`,
  );
}

/** @internal */
export const PostV2WebhooksDollarOrNotEqualsResponse$inboundSchema:
  z.ZodMiniType<PostV2WebhooksDollarOrNotEqualsResponse, unknown> = z.object({
    field: types.string(),
    operator: types.literal("not_equals"),
    value: types.string(),
  });

export function postV2WebhooksDollarOrNotEqualsResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV2WebhooksDollarOrNotEqualsResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2WebhooksDollarOrNotEqualsResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV2WebhooksDollarOrNotEqualsResponse' from JSON`,
  );
}

/** @internal */
export const PostV2WebhooksDollarOrEqualsResponse$inboundSchema: z.ZodMiniType<
  PostV2WebhooksDollarOrEqualsResponse,
  unknown
> = z.object({
  field: types.string(),
  operator: types.literal("equals"),
  value: types.string(),
});

export function postV2WebhooksDollarOrEqualsResponseFromJSON(
  jsonString: string,
): SafeParseResult<PostV2WebhooksDollarOrEqualsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2WebhooksDollarOrEqualsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2WebhooksDollarOrEqualsResponse' from JSON`,
  );
}

/** @internal */
export const PostV2WebhooksDollarOrResponseUnion$inboundSchema: z.ZodMiniType<
  PostV2WebhooksDollarOrResponseUnion,
  unknown
> = discriminatedUnion("operator", {
  equals: z.lazy(() => PostV2WebhooksDollarOrEqualsResponse$inboundSchema),
  not_equals: z.lazy(() =>
    PostV2WebhooksDollarOrNotEqualsResponse$inboundSchema
  ),
});

export function postV2WebhooksDollarOrResponseUnionFromJSON(
  jsonString: string,
): SafeParseResult<PostV2WebhooksDollarOrResponseUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2WebhooksDollarOrResponseUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2WebhooksDollarOrResponseUnion' from JSON`,
  );
}

/** @internal */
export const PostV2WebhooksFilterResponse1$inboundSchema: z.ZodMiniType<
  PostV2WebhooksFilterResponse1,
  unknown
> = z.pipe(
  z.object({
    $or: z.array(discriminatedUnion("operator", {
      equals: z.lazy(() => PostV2WebhooksDollarOrEqualsResponse$inboundSchema),
      not_equals: z.lazy(() =>
        PostV2WebhooksDollarOrNotEqualsResponse$inboundSchema
      ),
    })),
  }),
  z.transform((v) => {
    return remap$(v, {
      "$or": "dollarOr",
    });
  }),
);

export function postV2WebhooksFilterResponse1FromJSON(
  jsonString: string,
): SafeParseResult<PostV2WebhooksFilterResponse1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostV2WebhooksFilterResponse1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2WebhooksFilterResponse1' from JSON`,
  );
}

/** @internal */
export const PostV2WebhooksFilterResponseUnion$inboundSchema: z.ZodMiniType<
  PostV2WebhooksFilterResponseUnion,
  unknown
> = smartUnion([
  z.lazy(() => PostV2WebhooksFilterResponse1$inboundSchema),
  z.lazy(() => PostV2WebhooksFilterResponse2$inboundSchema),
]);

export function postV2WebhooksFilterResponseUnionFromJSON(
  jsonString: string,
): SafeParseResult<PostV2WebhooksFilterResponseUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostV2WebhooksFilterResponseUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2WebhooksFilterResponseUnion' from JSON`,
  );
}

/** @internal */
export const PostV2WebhooksSubscriptionResponse$inboundSchema: z.ZodMiniType<
  PostV2WebhooksSubscriptionResponse,
  unknown
> = z.pipe(
  z.object({
    event_type: PostV2WebhooksEventTypeResponse$inboundSchema,
    filter: types.nullable(smartUnion([
      z.lazy(() => PostV2WebhooksFilterResponse1$inboundSchema),
      z.lazy(() => PostV2WebhooksFilterResponse2$inboundSchema),
    ])),
  }),
  z.transform((v) => {
    return remap$(v, {
      "event_type": "eventType",
    });
  }),
);

export function postV2WebhooksSubscriptionResponseFromJSON(
  jsonString: string,
): SafeParseResult<PostV2WebhooksSubscriptionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2WebhooksSubscriptionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2WebhooksSubscriptionResponse' from JSON`,
  );
}

/** @internal */
export const PostV2WebhooksId$inboundSchema: z.ZodMiniType<
  PostV2WebhooksId,
  unknown
> = z.pipe(
  z.object({
    workspace_id: types.string(),
    webhook_id: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "workspace_id": "workspaceId",
      "webhook_id": "webhookId",
    });
  }),
);

export function postV2WebhooksIdFromJSON(
  jsonString: string,
): SafeParseResult<PostV2WebhooksId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostV2WebhooksId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2WebhooksId' from JSON`,
  );
}

/** @internal */
export const PostV2WebhooksStatus$inboundSchema: z.ZodMiniType<
  PostV2WebhooksStatus,
  unknown
> = openEnums.inboundSchema(PostV2WebhooksStatus);

/** @internal */
export const PostV2WebhooksDataResponse$inboundSchema: z.ZodMiniType<
  PostV2WebhooksDataResponse,
  unknown
> = z.pipe(
  z.object({
    target_url: types.string(),
    subscriptions: z.array(
      z.lazy(() => PostV2WebhooksSubscriptionResponse$inboundSchema),
    ),
    id: z.lazy(() => PostV2WebhooksId$inboundSchema),
    status: PostV2WebhooksStatus$inboundSchema,
    created_at: types.string(),
    secret: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "target_url": "targetUrl",
      "created_at": "createdAt",
    });
  }),
);

export function postV2WebhooksDataResponseFromJSON(
  jsonString: string,
): SafeParseResult<PostV2WebhooksDataResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostV2WebhooksDataResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2WebhooksDataResponse' from JSON`,
  );
}

/** @internal */
export const PostV2WebhooksResponse$inboundSchema: z.ZodMiniType<
  PostV2WebhooksResponse,
  unknown
> = z.object({
  data: z.lazy(() => PostV2WebhooksDataResponse$inboundSchema),
});

export function postV2WebhooksResponseFromJSON(
  jsonString: string,
): SafeParseResult<PostV2WebhooksResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostV2WebhooksResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2WebhooksResponse' from JSON`,
  );
}
