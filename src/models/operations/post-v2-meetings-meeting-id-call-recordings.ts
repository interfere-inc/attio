/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { smartUnion } from "../../types/smart-union.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

export type PostV2MeetingsMeetingIdCallRecordingsDataRequest = {
  /**
   * A publicly accessible URL to a video file of the call recording. Attio will download the video from this URL asynchronously.
   *
   * @remarks
   *
   * **Requirements:**
   * - **Protocol:** The URL must use the `https` protocol.
   * - **File type:** The file must be a `.mp4` file.
   * - **File size:** The file must not exceed 500MB in size.
   * - **Accessibility:** For the request to be accepted, the URL must be publicly accessible. Attio will make a `HEAD` request to the URL to verify its accessibility and retrieve file metadata. The response to this request must include a `Content-Length` header.
   */
  videoUrl: string;
};

export type PostV2MeetingsMeetingIdCallRecordingsRequestBody = {
  data: PostV2MeetingsMeetingIdCallRecordingsDataRequest;
};

export type PostV2MeetingsMeetingIdCallRecordingsRequest = {
  meetingId: string;
  body: PostV2MeetingsMeetingIdCallRecordingsRequestBody;
};

export const PostV2MeetingsMeetingIdCallRecordingsNotFoundType = {
  InvalidRequestError: "invalid_request_error",
} as const;
export type PostV2MeetingsMeetingIdCallRecordingsNotFoundType = ClosedEnum<
  typeof PostV2MeetingsMeetingIdCallRecordingsNotFoundType
>;

export const PostV2MeetingsMeetingIdCallRecordingsNotFoundCode = {
  NotFound: "not_found",
} as const;
export type PostV2MeetingsMeetingIdCallRecordingsNotFoundCode = ClosedEnum<
  typeof PostV2MeetingsMeetingIdCallRecordingsNotFoundCode
>;

export const PostV2MeetingsMeetingIdCallRecordingsForbiddenType = {
  AuthError: "auth_error",
} as const;
export type PostV2MeetingsMeetingIdCallRecordingsForbiddenType = ClosedEnum<
  typeof PostV2MeetingsMeetingIdCallRecordingsForbiddenType
>;

export const CodeQuotaExceeded = {
  QuotaExceeded: "quota_exceeded",
} as const;
export type CodeQuotaExceeded = ClosedEnum<typeof CodeQuotaExceeded>;

export const PostV2MeetingsMeetingIdCallRecordingsCodeBillingError = {
  BillingError: "billing_error",
} as const;
export type PostV2MeetingsMeetingIdCallRecordingsCodeBillingError = ClosedEnum<
  typeof PostV2MeetingsMeetingIdCallRecordingsCodeBillingError
>;

export type Code =
  | PostV2MeetingsMeetingIdCallRecordingsCodeBillingError
  | CodeQuotaExceeded;

export const PostV2MeetingsMeetingIdCallRecordingsBadRequestType = {
  InvalidRequestError: "invalid_request_error",
} as const;
export type PostV2MeetingsMeetingIdCallRecordingsBadRequestType = ClosedEnum<
  typeof PostV2MeetingsMeetingIdCallRecordingsBadRequestType
>;

export const PostV2MeetingsMeetingIdCallRecordingsCodeValidationType = {
  ValidationType: "validation_type",
} as const;
export type PostV2MeetingsMeetingIdCallRecordingsCodeValidationType =
  ClosedEnum<typeof PostV2MeetingsMeetingIdCallRecordingsCodeValidationType>;

export type PostV2MeetingsMeetingIdCallRecordingsId = {
  /**
   * The ID of the workspace this call recording belongs to.
   */
  workspaceId: string;
  /**
   * The ID of the meeting associated with this call recording.
   */
  meetingId: string;
  /**
   * The call recording ID of the call recording.
   */
  callRecordingId: string;
};

/**
 * The status of the call recording. When a call recording is first created, it will have a status of `PROCESSING`. Once the recording is ready, it will transition to `COMPLETED`. If the recording fails for any reason, the status will be `FAILED`.
 */
export const PostV2MeetingsMeetingIdCallRecordingsStatus = {
  Processing: "processing",
  Completed: "completed",
  Failed: "failed",
} as const;
/**
 * The status of the call recording. When a call recording is first created, it will have a status of `PROCESSING`. Once the recording is ready, it will transition to `COMPLETED`. If the recording fails for any reason, the status will be `FAILED`.
 */
export type PostV2MeetingsMeetingIdCallRecordingsStatus = OpenEnum<
  typeof PostV2MeetingsMeetingIdCallRecordingsStatus
>;

/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export const PostV2MeetingsMeetingIdCallRecordingsCreatedByActorType = {
  ApiToken: "api-token",
  WorkspaceMember: "workspace-member",
  System: "system",
  App: "app",
} as const;
/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export type PostV2MeetingsMeetingIdCallRecordingsCreatedByActorType = OpenEnum<
  typeof PostV2MeetingsMeetingIdCallRecordingsCreatedByActorType
>;

/**
 * The actor that created this call recording.
 */
export type PostV2MeetingsMeetingIdCallRecordingsCreatedByActor = {
  /**
   * An ID to identify the actor.
   */
  id?: string | null | undefined;
  /**
   * The type of actor. [Read more information on actor types here](/docs/actors).
   */
  type?:
    | PostV2MeetingsMeetingIdCallRecordingsCreatedByActorType
    | null
    | undefined;
};

export type PostV2MeetingsMeetingIdCallRecordingsDataResponse = {
  id: PostV2MeetingsMeetingIdCallRecordingsId;
  /**
   * The status of the call recording. When a call recording is first created, it will have a status of `PROCESSING`. Once the recording is ready, it will transition to `COMPLETED`. If the recording fails for any reason, the status will be `FAILED`.
   */
  status: PostV2MeetingsMeetingIdCallRecordingsStatus;
  /**
   * A URL that links directly to the call recording in the Attio web application.
   */
  webUrl: string;
  /**
   * The actor that created this call recording.
   */
  createdByActor: PostV2MeetingsMeetingIdCallRecordingsCreatedByActor;
  /**
   * The timestamp of when the call recording was created.
   */
  createdAt: string;
};

/**
 * Success
 */
export type PostV2MeetingsMeetingIdCallRecordingsResponse = {
  data: PostV2MeetingsMeetingIdCallRecordingsDataResponse;
};

/** @internal */
export type PostV2MeetingsMeetingIdCallRecordingsDataRequest$Outbound = {
  video_url: string;
};

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsDataRequest$outboundSchema:
  z.ZodMiniType<
    PostV2MeetingsMeetingIdCallRecordingsDataRequest$Outbound,
    PostV2MeetingsMeetingIdCallRecordingsDataRequest
  > = z.pipe(
    z.object({
      videoUrl: z.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        videoUrl: "video_url",
      });
    }),
  );

export function postV2MeetingsMeetingIdCallRecordingsDataRequestToJSON(
  postV2MeetingsMeetingIdCallRecordingsDataRequest:
    PostV2MeetingsMeetingIdCallRecordingsDataRequest,
): string {
  return JSON.stringify(
    PostV2MeetingsMeetingIdCallRecordingsDataRequest$outboundSchema.parse(
      postV2MeetingsMeetingIdCallRecordingsDataRequest,
    ),
  );
}

/** @internal */
export type PostV2MeetingsMeetingIdCallRecordingsRequestBody$Outbound = {
  data: PostV2MeetingsMeetingIdCallRecordingsDataRequest$Outbound;
};

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsRequestBody$outboundSchema:
  z.ZodMiniType<
    PostV2MeetingsMeetingIdCallRecordingsRequestBody$Outbound,
    PostV2MeetingsMeetingIdCallRecordingsRequestBody
  > = z.object({
    data: z.lazy(() =>
      PostV2MeetingsMeetingIdCallRecordingsDataRequest$outboundSchema
    ),
  });

export function postV2MeetingsMeetingIdCallRecordingsRequestBodyToJSON(
  postV2MeetingsMeetingIdCallRecordingsRequestBody:
    PostV2MeetingsMeetingIdCallRecordingsRequestBody,
): string {
  return JSON.stringify(
    PostV2MeetingsMeetingIdCallRecordingsRequestBody$outboundSchema.parse(
      postV2MeetingsMeetingIdCallRecordingsRequestBody,
    ),
  );
}

/** @internal */
export type PostV2MeetingsMeetingIdCallRecordingsRequest$Outbound = {
  meeting_id: string;
  body: PostV2MeetingsMeetingIdCallRecordingsRequestBody$Outbound;
};

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsRequest$outboundSchema:
  z.ZodMiniType<
    PostV2MeetingsMeetingIdCallRecordingsRequest$Outbound,
    PostV2MeetingsMeetingIdCallRecordingsRequest
  > = z.pipe(
    z.object({
      meetingId: z.string(),
      body: z.lazy(() =>
        PostV2MeetingsMeetingIdCallRecordingsRequestBody$outboundSchema
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        meetingId: "meeting_id",
      });
    }),
  );

export function postV2MeetingsMeetingIdCallRecordingsRequestToJSON(
  postV2MeetingsMeetingIdCallRecordingsRequest:
    PostV2MeetingsMeetingIdCallRecordingsRequest,
): string {
  return JSON.stringify(
    PostV2MeetingsMeetingIdCallRecordingsRequest$outboundSchema.parse(
      postV2MeetingsMeetingIdCallRecordingsRequest,
    ),
  );
}

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsNotFoundType$inboundSchema:
  z.ZodMiniEnum<typeof PostV2MeetingsMeetingIdCallRecordingsNotFoundType> = z
    .enum(PostV2MeetingsMeetingIdCallRecordingsNotFoundType);

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsNotFoundCode$inboundSchema:
  z.ZodMiniEnum<typeof PostV2MeetingsMeetingIdCallRecordingsNotFoundCode> = z
    .enum(PostV2MeetingsMeetingIdCallRecordingsNotFoundCode);

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsForbiddenType$inboundSchema:
  z.ZodMiniEnum<typeof PostV2MeetingsMeetingIdCallRecordingsForbiddenType> = z
    .enum(PostV2MeetingsMeetingIdCallRecordingsForbiddenType);

/** @internal */
export const CodeQuotaExceeded$inboundSchema: z.ZodMiniEnum<
  typeof CodeQuotaExceeded
> = z.enum(CodeQuotaExceeded);

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsCodeBillingError$inboundSchema:
  z.ZodMiniEnum<typeof PostV2MeetingsMeetingIdCallRecordingsCodeBillingError> =
    z.enum(PostV2MeetingsMeetingIdCallRecordingsCodeBillingError);

/** @internal */
export const Code$inboundSchema: z.ZodMiniType<Code, unknown> = smartUnion([
  PostV2MeetingsMeetingIdCallRecordingsCodeBillingError$inboundSchema,
  CodeQuotaExceeded$inboundSchema,
]);

export function codeFromJSON(
  jsonString: string,
): SafeParseResult<Code, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Code$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Code' from JSON`,
  );
}

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsBadRequestType$inboundSchema:
  z.ZodMiniEnum<typeof PostV2MeetingsMeetingIdCallRecordingsBadRequestType> = z
    .enum(PostV2MeetingsMeetingIdCallRecordingsBadRequestType);

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsCodeValidationType$inboundSchema:
  z.ZodMiniEnum<
    typeof PostV2MeetingsMeetingIdCallRecordingsCodeValidationType
  > = z.enum(PostV2MeetingsMeetingIdCallRecordingsCodeValidationType);

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsId$inboundSchema:
  z.ZodMiniType<PostV2MeetingsMeetingIdCallRecordingsId, unknown> = z.pipe(
    z.object({
      workspace_id: types.string(),
      meeting_id: types.string(),
      call_recording_id: types.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        "workspace_id": "workspaceId",
        "meeting_id": "meetingId",
        "call_recording_id": "callRecordingId",
      });
    }),
  );

export function postV2MeetingsMeetingIdCallRecordingsIdFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV2MeetingsMeetingIdCallRecordingsId,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2MeetingsMeetingIdCallRecordingsId$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV2MeetingsMeetingIdCallRecordingsId' from JSON`,
  );
}

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsStatus$inboundSchema:
  z.ZodMiniType<PostV2MeetingsMeetingIdCallRecordingsStatus, unknown> =
    openEnums.inboundSchema(PostV2MeetingsMeetingIdCallRecordingsStatus);

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsCreatedByActorType$inboundSchema:
  z.ZodMiniType<
    PostV2MeetingsMeetingIdCallRecordingsCreatedByActorType,
    unknown
  > = openEnums.inboundSchema(
    PostV2MeetingsMeetingIdCallRecordingsCreatedByActorType,
  );

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsCreatedByActor$inboundSchema:
  z.ZodMiniType<PostV2MeetingsMeetingIdCallRecordingsCreatedByActor, unknown> =
    z.object({
      id: z.optional(z.nullable(types.string())),
      type: z.optional(
        z.nullable(
          PostV2MeetingsMeetingIdCallRecordingsCreatedByActorType$inboundSchema,
        ),
      ),
    });

export function postV2MeetingsMeetingIdCallRecordingsCreatedByActorFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV2MeetingsMeetingIdCallRecordingsCreatedByActor,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2MeetingsMeetingIdCallRecordingsCreatedByActor$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV2MeetingsMeetingIdCallRecordingsCreatedByActor' from JSON`,
  );
}

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsDataResponse$inboundSchema:
  z.ZodMiniType<PostV2MeetingsMeetingIdCallRecordingsDataResponse, unknown> = z
    .pipe(
      z.object({
        id: z.lazy(() => PostV2MeetingsMeetingIdCallRecordingsId$inboundSchema),
        status: PostV2MeetingsMeetingIdCallRecordingsStatus$inboundSchema,
        web_url: types.string(),
        created_by_actor: z.lazy(() =>
          PostV2MeetingsMeetingIdCallRecordingsCreatedByActor$inboundSchema
        ),
        created_at: types.string(),
      }),
      z.transform((v) => {
        return remap$(v, {
          "web_url": "webUrl",
          "created_by_actor": "createdByActor",
          "created_at": "createdAt",
        });
      }),
    );

export function postV2MeetingsMeetingIdCallRecordingsDataResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV2MeetingsMeetingIdCallRecordingsDataResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2MeetingsMeetingIdCallRecordingsDataResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV2MeetingsMeetingIdCallRecordingsDataResponse' from JSON`,
  );
}

/** @internal */
export const PostV2MeetingsMeetingIdCallRecordingsResponse$inboundSchema:
  z.ZodMiniType<PostV2MeetingsMeetingIdCallRecordingsResponse, unknown> = z
    .object({
      data: z.lazy(() =>
        PostV2MeetingsMeetingIdCallRecordingsDataResponse$inboundSchema
      ),
    });

export function postV2MeetingsMeetingIdCallRecordingsResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV2MeetingsMeetingIdCallRecordingsResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2MeetingsMeetingIdCallRecordingsResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV2MeetingsMeetingIdCallRecordingsResponse' from JSON`,
  );
}
