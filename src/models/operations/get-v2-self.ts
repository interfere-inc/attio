/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { smartUnion } from "../../types/smart-union.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * The type of token, always Bearer for tokens acquired via the OAuth 2.0 flow.
 */
export const TokenType = {
  Bearer: "Bearer",
} as const;
/**
 * The type of token, always Bearer for tokens acquired via the OAuth 2.0 flow.
 */
export type TokenType = ClosedEnum<typeof TokenType>;

/**
 * The issuer of the token. Always attio.com
 */
export const Iss = {
  AttioCom: "attio.com",
} as const;
/**
 * The issuer of the token. Always attio.com
 */
export type Iss = ClosedEnum<typeof Iss>;

export type AttioCom = {
  /**
   * Whether the token is currently active and usable.
   */
  active: boolean;
  /**
   * A space-separated list of scopes associated with this token
   */
  scope: string;
  /**
   * The app ID of the OAuth application that requested this token
   */
  clientId: string;
  /**
   * The type of token, always Bearer for tokens acquired via the OAuth 2.0 flow.
   */
  tokenType: TokenType;
  /**
   * The time at which this token will expire, if set, as a number of seconds since January 1 1970 UTC.
   */
  exp: number | null;
  /**
   * The time at which this token was issued, as a number of seconds since January 1 1970 UTC.
   */
  iat: number;
  /**
   * Since Bearer tokens grant Workspace-level permissions, this property contains the workspace_id.
   */
  sub: string;
  /**
   * The intended audience for this token, for Bearer tokens this is the same as the client_id.
   */
  aud: string;
  /**
   * The issuer of the token. Always attio.com
   */
  iss: Iss;
  /**
   * The ID of the workspace member who authorised this token initially.
   */
  authorizedByWorkspaceMemberId: string;
  /**
   * The ID of the workspace the token is scoped to.
   */
  workspaceId: string;
  /**
   * The name of the workspace the token is scoped to.
   */
  workspaceName: string;
  /**
   * The slug of the workspace the token is scoped to.
   */
  workspaceSlug: string;
  /**
   * The logo URL of the workspace the token is scoped to.
   */
  workspaceLogoUrl: string | null;
};

export type ResponseBody = {
  active: boolean;
};

/**
 * Success
 */
export type GetV2SelfResponse = AttioCom | ResponseBody;

/** @internal */
export const TokenType$inboundSchema: z.ZodMiniEnum<typeof TokenType> = z.enum(
  TokenType,
);

/** @internal */
export const Iss$inboundSchema: z.ZodMiniEnum<typeof Iss> = z.enum(Iss);

/** @internal */
export const AttioCom$inboundSchema: z.ZodMiniType<AttioCom, unknown> = z.pipe(
  z.object({
    active: types.boolean(),
    scope: types.string(),
    client_id: types.string(),
    token_type: TokenType$inboundSchema,
    exp: types.nullable(types.number()),
    iat: types.number(),
    sub: types.string(),
    aud: types.string(),
    iss: Iss$inboundSchema,
    authorized_by_workspace_member_id: types.string(),
    workspace_id: types.string(),
    workspace_name: types.string(),
    workspace_slug: types.string(),
    workspace_logo_url: types.nullable(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "client_id": "clientId",
      "token_type": "tokenType",
      "authorized_by_workspace_member_id": "authorizedByWorkspaceMemberId",
      "workspace_id": "workspaceId",
      "workspace_name": "workspaceName",
      "workspace_slug": "workspaceSlug",
      "workspace_logo_url": "workspaceLogoUrl",
    });
  }),
);

export function attioComFromJSON(
  jsonString: string,
): SafeParseResult<AttioCom, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AttioCom$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AttioCom' from JSON`,
  );
}

/** @internal */
export const ResponseBody$inboundSchema: z.ZodMiniType<ResponseBody, unknown> =
  z.object({
    active: types.boolean(),
  });

export function responseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody' from JSON`,
  );
}

/** @internal */
export const GetV2SelfResponse$inboundSchema: z.ZodMiniType<
  GetV2SelfResponse,
  unknown
> = smartUnion([
  z.lazy(() => AttioCom$inboundSchema),
  z.lazy(() => ResponseBody$inboundSchema),
]);

export function getV2SelfResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetV2SelfResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetV2SelfResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetV2SelfResponse' from JSON`,
  );
}
