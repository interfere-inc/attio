/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

export type TaskId = {
  /**
   * The ID of the workspace the task belongs to.
   */
  workspaceId: string;
  /**
   * The ID of the task.
   */
  taskId: string;
};

export type TaskLinkedRecord = {
  /**
   * The ID of the parent object the task refers to. At present, only `people` and `companies` are supported.
   */
  targetObjectId: string;
  /**
   * The ID of the parent record the task refers to.
   */
  targetRecordId: string;
};

/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export const TaskReferencedActorType = {
  ApiToken: "api-token",
  WorkspaceMember: "workspace-member",
  System: "system",
  App: "app",
} as const;
/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export type TaskReferencedActorType = OpenEnum<typeof TaskReferencedActorType>;

export type Assignee = {
  /**
   * The type of actor. [Read more information on actor types here](/docs/actors).
   */
  referencedActorType: TaskReferencedActorType;
  /**
   * The ID of the workspace member actor assigned to this task.
   */
  referencedActorId: string;
};

/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export const TaskType = {
  ApiToken: "api-token",
  WorkspaceMember: "workspace-member",
  System: "system",
  App: "app",
} as const;
/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export type TaskType = OpenEnum<typeof TaskType>;

/**
 * The actor that created this task.
 */
export type TaskCreatedByActor = {
  /**
   * An ID to identify the actor.
   */
  id?: string | null | undefined;
  /**
   * The type of actor. [Read more information on actor types here](/docs/actors).
   */
  type?: TaskType | null | undefined;
};

export type Task = {
  id: TaskId;
  /**
   * The plaintext representation of the task content. Inline linked records will appear as "@record name" and are returned in the `linked_records` property.
   */
  contentPlaintext: string;
  /**
   * The deadline date of the task. Returned as an ISO 8601 timestamp.
   */
  deadlineAt: string | null;
  /**
   * Whether the task has been completed.
   */
  isCompleted: boolean;
  /**
   * Records linked to the task. Creating record links within task content text is not possible via the API at present.
   */
  linkedRecords: Array<TaskLinkedRecord>;
  /**
   * Workspace members assigned to this task.
   */
  assignees: Array<Assignee>;
  /**
   * The actor that created this task.
   */
  createdByActor: TaskCreatedByActor;
  /**
   * When the task was created.
   */
  createdAt: string;
};

/** @internal */
export const TaskId$inboundSchema: z.ZodMiniType<TaskId, unknown> = z.pipe(
  z.object({
    workspace_id: types.string(),
    task_id: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "workspace_id": "workspaceId",
      "task_id": "taskId",
    });
  }),
);

export function taskIdFromJSON(
  jsonString: string,
): SafeParseResult<TaskId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TaskId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TaskId' from JSON`,
  );
}

/** @internal */
export const TaskLinkedRecord$inboundSchema: z.ZodMiniType<
  TaskLinkedRecord,
  unknown
> = z.pipe(
  z.object({
    target_object_id: types.string(),
    target_record_id: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "target_object_id": "targetObjectId",
      "target_record_id": "targetRecordId",
    });
  }),
);

export function taskLinkedRecordFromJSON(
  jsonString: string,
): SafeParseResult<TaskLinkedRecord, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TaskLinkedRecord$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TaskLinkedRecord' from JSON`,
  );
}

/** @internal */
export const TaskReferencedActorType$inboundSchema: z.ZodMiniType<
  TaskReferencedActorType,
  unknown
> = openEnums.inboundSchema(TaskReferencedActorType);

/** @internal */
export const Assignee$inboundSchema: z.ZodMiniType<Assignee, unknown> = z.pipe(
  z.object({
    referenced_actor_type: TaskReferencedActorType$inboundSchema,
    referenced_actor_id: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "referenced_actor_type": "referencedActorType",
      "referenced_actor_id": "referencedActorId",
    });
  }),
);

export function assigneeFromJSON(
  jsonString: string,
): SafeParseResult<Assignee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Assignee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Assignee' from JSON`,
  );
}

/** @internal */
export const TaskType$inboundSchema: z.ZodMiniType<TaskType, unknown> =
  openEnums.inboundSchema(TaskType);

/** @internal */
export const TaskCreatedByActor$inboundSchema: z.ZodMiniType<
  TaskCreatedByActor,
  unknown
> = z.object({
  id: z.optional(z.nullable(types.string())),
  type: z.optional(z.nullable(TaskType$inboundSchema)),
});

export function taskCreatedByActorFromJSON(
  jsonString: string,
): SafeParseResult<TaskCreatedByActor, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TaskCreatedByActor$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TaskCreatedByActor' from JSON`,
  );
}

/** @internal */
export const Task$inboundSchema: z.ZodMiniType<Task, unknown> = z.pipe(
  z.object({
    id: z.lazy(() => TaskId$inboundSchema),
    content_plaintext: types.string(),
    deadline_at: types.nullable(types.string()),
    is_completed: types.boolean(),
    linked_records: z.array(z.lazy(() => TaskLinkedRecord$inboundSchema)),
    assignees: z.array(z.lazy(() => Assignee$inboundSchema)),
    created_by_actor: z.lazy(() => TaskCreatedByActor$inboundSchema),
    created_at: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "content_plaintext": "contentPlaintext",
      "deadline_at": "deadlineAt",
      "is_completed": "isCompleted",
      "linked_records": "linkedRecords",
      "created_by_actor": "createdByActor",
      "created_at": "createdAt",
    });
  }),
);

export function taskFromJSON(
  jsonString: string,
): SafeParseResult<Task, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Task$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Task' from JSON`,
  );
}
