/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminated-union.js";
import { discriminatedUnion } from "../types/discriminated-union.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

export type NoteId = {
  /**
   * The ID of the workspace the note belongs to.
   */
  workspaceId: string;
  /**
   * The ID of the note.
   */
  noteId: string;
};

export type TagRecord = {
  /**
   * The type of entity tagged in the note. Can be either 'workspace-member' or 'record'
   */
  type: "record";
  /**
   * The slug or ID of the object that the tagged record belongs to.
   */
  object: string;
  /**
   * The ID of the record that is tagged in the note.
   */
  recordId: string;
};

export type TagWorkspaceMember = {
  /**
   * The type of entity tagged in the note. Can be either 'workspace-member' or 'record'
   */
  type: "workspace-member";
  /**
   * The ID of the workspace member that is tagged in the note.
   */
  workspaceMemberId: string;
};

export type Tag =
  | TagWorkspaceMember
  | TagRecord
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export const NoteCreatedByActorType = {
  ApiToken: "api-token",
  WorkspaceMember: "workspace-member",
  System: "system",
  App: "app",
} as const;
/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export type NoteCreatedByActorType = OpenEnum<typeof NoteCreatedByActorType>;

/**
 * The actor that created this note.
 */
export type NoteCreatedByActor = {
  /**
   * An ID to identify the actor.
   */
  id?: string | null | undefined;
  /**
   * The type of actor. [Read more information on actor types here](/docs/actors).
   */
  type?: NoteCreatedByActorType | null | undefined;
};

export type Note = {
  id: NoteId;
  /**
   * The slug or ID of the parent object the note belongs to.
   */
  parentObject: string;
  /**
   * The ID of the parent record the note belongs to.
   */
  parentRecordId: string;
  /**
   * The note title. The title is plaintext only and has no formatting.
   */
  title: string;
  /**
   * The ID of the meeting associated with this note, or null if no meeting is associated.
   */
  meetingId: string | null;
  /**
   * The plaintext representation of the note content. The line feed character `\n` represents new lines within the note content.
   */
  contentPlaintext: string;
  /**
   * The markdown representation of the note content. Supports a subset of markdown features including:
   *
   * @remarks
   * - Headings (levels 1-3 only with `#`, `##`, `###`)
   * - Unordered lists (`-`, `*`, `+`)
   * - Ordered lists (`1.`, `2.`, etc.)
   * - Text styling: `**bold**`, `*italic*`, `~~strikethrough~~`, `==highlighted==`
   * - Links: `[link text](https://example.com)`
   *
   * Note that note images are not returned as part of the markdown API representation.
   */
  contentMarkdown: string;
  /**
   * An array of records or workspace members that are @-tagged in the note content.
   */
  tags: Array<
    TagWorkspaceMember | TagRecord | discriminatedUnionTypes.Unknown<"type">
  >;
  /**
   * The actor that created this note.
   */
  createdByActor: NoteCreatedByActor;
  /**
   * When the note was created.
   */
  createdAt: string;
};

/** @internal */
export const NoteId$inboundSchema: z.ZodMiniType<NoteId, unknown> = z.pipe(
  z.object({
    workspace_id: types.string(),
    note_id: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "workspace_id": "workspaceId",
      "note_id": "noteId",
    });
  }),
);

export function noteIdFromJSON(
  jsonString: string,
): SafeParseResult<NoteId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteId' from JSON`,
  );
}

/** @internal */
export const TagRecord$inboundSchema: z.ZodMiniType<TagRecord, unknown> = z
  .pipe(
    z.object({
      type: types.literal("record"),
      object: types.string(),
      record_id: types.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        "record_id": "recordId",
      });
    }),
  );

export function tagRecordFromJSON(
  jsonString: string,
): SafeParseResult<TagRecord, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TagRecord$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TagRecord' from JSON`,
  );
}

/** @internal */
export const TagWorkspaceMember$inboundSchema: z.ZodMiniType<
  TagWorkspaceMember,
  unknown
> = z.pipe(
  z.object({
    type: types.literal("workspace-member"),
    workspace_member_id: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "workspace_member_id": "workspaceMemberId",
    });
  }),
);

export function tagWorkspaceMemberFromJSON(
  jsonString: string,
): SafeParseResult<TagWorkspaceMember, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TagWorkspaceMember$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TagWorkspaceMember' from JSON`,
  );
}

/** @internal */
export const Tag$inboundSchema: z.ZodMiniType<Tag, unknown> =
  discriminatedUnion("type", {
    ["workspace-member"]: z.lazy(() => TagWorkspaceMember$inboundSchema),
    record: z.lazy(() => TagRecord$inboundSchema),
  });

export function tagFromJSON(
  jsonString: string,
): SafeParseResult<Tag, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tag$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tag' from JSON`,
  );
}

/** @internal */
export const NoteCreatedByActorType$inboundSchema: z.ZodMiniType<
  NoteCreatedByActorType,
  unknown
> = openEnums.inboundSchema(NoteCreatedByActorType);

/** @internal */
export const NoteCreatedByActor$inboundSchema: z.ZodMiniType<
  NoteCreatedByActor,
  unknown
> = z.object({
  id: z.optional(z.nullable(types.string())),
  type: z.optional(z.nullable(NoteCreatedByActorType$inboundSchema)),
});

export function noteCreatedByActorFromJSON(
  jsonString: string,
): SafeParseResult<NoteCreatedByActor, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NoteCreatedByActor$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NoteCreatedByActor' from JSON`,
  );
}

/** @internal */
export const Note$inboundSchema: z.ZodMiniType<Note, unknown> = z.pipe(
  z.object({
    id: z.lazy(() => NoteId$inboundSchema),
    parent_object: types.string(),
    parent_record_id: types.string(),
    title: types.string(),
    meeting_id: types.nullable(types.string()),
    content_plaintext: types.string(),
    content_markdown: types.string(),
    tags: z.array(
      discriminatedUnion("type", {
        ["workspace-member"]: z.lazy(() => TagWorkspaceMember$inboundSchema),
        record: z.lazy(() => TagRecord$inboundSchema),
      }),
    ),
    created_by_actor: z.lazy(() => NoteCreatedByActor$inboundSchema),
    created_at: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "parent_object": "parentObject",
      "parent_record_id": "parentRecordId",
      "meeting_id": "meetingId",
      "content_plaintext": "contentPlaintext",
      "content_markdown": "contentMarkdown",
      "created_by_actor": "createdByActor",
      "created_at": "createdAt",
    });
  }),
);

export function noteFromJSON(
  jsonString: string,
): SafeParseResult<Note, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Note$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Note' from JSON`,
  );
}
