/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { ClosedEnum } from "../types/enums.js";
import { smartUnion } from "../types/smart-union.js";

export type InputValue18 = {
  /**
   * A timestamp value represents a single, universal moment in time using an ISO 8601 formatted string. This means that a timestamp consists of a date, a time (with nanosecond precision), and a time zone. Attio will coerce timestamps which do not provide full nanosecond precision and UTC is assumed if no time zone is provided. For example, "2023", "2023-01", "2023-01-02", "2023-01-02T13:00", "2023-01-02T13:00:00", and "2023-01-02T13:00:00.000000000" will all be coerced to "2023-01-02T13:00:00.000000000Z". Timestamps are always returned in UTC. For example, writing a timestamp value using the string "2023-01-02T13:00:00.000000000+02:00" will result in the value "2023-01-02T11:00:00.000000000Z" being returned. The maximum date is "9999-12-31T23:59:59.999999999Z".
   */
  value: Date;
};

export type InputValue17 = {
  /**
   * A raw text field. Values are limited to 10MB.
   */
  value: string;
};

export type InputValue16 = {
  /**
   * The UUID or select option title identifying the selected select option.
   */
  option: string;
};

export type InputValue15 = {
  /**
   * A number between 0 and 5 (inclusive) to represent a star rating.
   */
  value: number;
};

export type InputValue14 = {
  /**
   * The UUID or status title identifying the selected status.
   */
  status: string;
};

/**
 * The ISO 3166-1 alpha-2 country code representing the country that this phone number belongs to. Optional if `original_phone_number` includes a country code prefix.
 */
export const InputValueCountryCode2 = {
  Af: "AF",
  Ax: "AX",
  Al: "AL",
  Dz: "DZ",
  As: "AS",
  Ad: "AD",
  Ao: "AO",
  Ai: "AI",
  Aq: "AQ",
  Ag: "AG",
  Ar: "AR",
  Am: "AM",
  Aw: "AW",
  Au: "AU",
  At: "AT",
  Az: "AZ",
  Bs: "BS",
  Bh: "BH",
  Bd: "BD",
  Bb: "BB",
  By: "BY",
  Be: "BE",
  Bz: "BZ",
  Bj: "BJ",
  Bm: "BM",
  Bt: "BT",
  Bo: "BO",
  Ba: "BA",
  Bw: "BW",
  Bv: "BV",
  Br: "BR",
  Io: "IO",
  Bn: "BN",
  Bg: "BG",
  Bf: "BF",
  Bi: "BI",
  Kh: "KH",
  Cm: "CM",
  Ca: "CA",
  Cv: "CV",
  Ky: "KY",
  Cf: "CF",
  Td: "TD",
  Cl: "CL",
  Cn: "CN",
  Cx: "CX",
  Cc: "CC",
  Co: "CO",
  Km: "KM",
  Cg: "CG",
  Cd: "CD",
  Ck: "CK",
  Cr: "CR",
  Ci: "CI",
  Hr: "HR",
  Cu: "CU",
  Cw: "CW",
  Cy: "CY",
  Cz: "CZ",
  Dk: "DK",
  Dj: "DJ",
  Dm: "DM",
  Do: "DO",
  Ec: "EC",
  Eg: "EG",
  Sv: "SV",
  Gq: "GQ",
  Er: "ER",
  Ee: "EE",
  Et: "ET",
  Fk: "FK",
  Fo: "FO",
  Fj: "FJ",
  Fi: "FI",
  Fr: "FR",
  Gf: "GF",
  Pf: "PF",
  Tf: "TF",
  Ga: "GA",
  Gm: "GM",
  Ge: "GE",
  De: "DE",
  Gh: "GH",
  Gi: "GI",
  Gr: "GR",
  Gl: "GL",
  Gd: "GD",
  Gp: "GP",
  Gu: "GU",
  Gt: "GT",
  Gg: "GG",
  Gn: "GN",
  Gw: "GW",
  Gy: "GY",
  Ht: "HT",
  Hm: "HM",
  Va: "VA",
  Hn: "HN",
  Hk: "HK",
  Hu: "HU",
  Is: "IS",
  In: "IN",
  Id: "ID",
  Ir: "IR",
  Iq: "IQ",
  Ie: "IE",
  Im: "IM",
  Il: "IL",
  It: "IT",
  Jm: "JM",
  Jp: "JP",
  Je: "JE",
  Jo: "JO",
  Kz: "KZ",
  Ke: "KE",
  Ki: "KI",
  Kr: "KR",
  Kw: "KW",
  Kg: "KG",
  La: "LA",
  Lv: "LV",
  Lb: "LB",
  Ls: "LS",
  Lr: "LR",
  Ly: "LY",
  Li: "LI",
  Lt: "LT",
  Lu: "LU",
  Mo: "MO",
  Mk: "MK",
  Mg: "MG",
  Mw: "MW",
  My: "MY",
  Mv: "MV",
  Ml: "ML",
  Mt: "MT",
  Mh: "MH",
  Mq: "MQ",
  Mr: "MR",
  Mu: "MU",
  Yt: "YT",
  Mx: "MX",
  Fm: "FM",
  Md: "MD",
  Mc: "MC",
  Mn: "MN",
  Me: "ME",
  Ms: "MS",
  Ma: "MA",
  Mz: "MZ",
  Mm: "MM",
  Na: "NA",
  Nr: "NR",
  Np: "NP",
  Nl: "NL",
  An: "AN",
  Nc: "NC",
  Nz: "NZ",
  Ni: "NI",
  Ne: "NE",
  Ng: "NG",
  Nu: "NU",
  Nf: "NF",
  Mp: "MP",
  No: "NO",
  Om: "OM",
  Pk: "PK",
  Pw: "PW",
  Ps: "PS",
  Pa: "PA",
  Pg: "PG",
  Py: "PY",
  Pe: "PE",
  Ph: "PH",
  Pn: "PN",
  Pl: "PL",
  Pt: "PT",
  Pr: "PR",
  Qa: "QA",
  Re: "RE",
  Ro: "RO",
  Ru: "RU",
  Rw: "RW",
  Bl: "BL",
  Sh: "SH",
  Kn: "KN",
  Lc: "LC",
  Mf: "MF",
  Pm: "PM",
  Vc: "VC",
  Ws: "WS",
  Sm: "SM",
  St: "ST",
  Sa: "SA",
  Sn: "SN",
  Ss: "SS",
  Rs: "RS",
  Sc: "SC",
  Sl: "SL",
  Sg: "SG",
  Sk: "SK",
  Si: "SI",
  Sb: "SB",
  So: "SO",
  Za: "ZA",
  Gs: "GS",
  Es: "ES",
  Lk: "LK",
  Sd: "SD",
  Sr: "SR",
  Sj: "SJ",
  Sz: "SZ",
  Se: "SE",
  Ch: "CH",
  Sy: "SY",
  Tw: "TW",
  Tj: "TJ",
  Tz: "TZ",
  Th: "TH",
  Tl: "TL",
  Tg: "TG",
  Tk: "TK",
  To: "TO",
  Tt: "TT",
  Tn: "TN",
  Tr: "TR",
  Tm: "TM",
  Tc: "TC",
  Tv: "TV",
  Ug: "UG",
  Ua: "UA",
  Ae: "AE",
  Gb: "GB",
  Us: "US",
  Um: "UM",
  Uy: "UY",
  Uz: "UZ",
  Vu: "VU",
  Ve: "VE",
  Vn: "VN",
  Vg: "VG",
  Vi: "VI",
  Wf: "WF",
  Eh: "EH",
  Ye: "YE",
  Zm: "ZM",
  Zw: "ZW",
  Bq: "BQ",
  Kp: "KP",
  Sx: "SX",
  Xk: "XK",
  Ac: "AC",
} as const;
/**
 * The ISO 3166-1 alpha-2 country code representing the country that this phone number belongs to. Optional if `original_phone_number` includes a country code prefix.
 */
export type InputValueCountryCode2 = ClosedEnum<typeof InputValueCountryCode2>;

export type InputValue13 = {
  /**
   * A phone number which is either a) prefixed with a country code (e.g. `+44....`) or b) a local number, where `country_code` is specified in addition.
   */
  originalPhoneNumber: string;
  /**
   * The ISO 3166-1 alpha-2 country code representing the country that this phone number belongs to. Optional if `original_phone_number` includes a country code prefix.
   */
  countryCode?: InputValueCountryCode2 | null | undefined;
};

export type InputValue12 = {
  /**
   * The first name.
   */
  firstName?: string | undefined;
  /**
   * The last name.
   */
  lastName?: string | undefined;
  /**
   * The full name.
   */
  fullName?: string | undefined;
};

export type InputValue11 = {
  /**
   * Numbers are persisted as 64 bit floats.
   */
  value: number;
};

/**
 * The ISO 3166-1 alpha-2 country code for the country this location is in.
 */
export const InputValueCountryCode1 = {
  Af: "AF",
  Ax: "AX",
  Al: "AL",
  Dz: "DZ",
  As: "AS",
  Ad: "AD",
  Ao: "AO",
  Ai: "AI",
  Aq: "AQ",
  Ag: "AG",
  Ar: "AR",
  Am: "AM",
  Aw: "AW",
  Au: "AU",
  At: "AT",
  Az: "AZ",
  Bs: "BS",
  Bh: "BH",
  Bd: "BD",
  Bb: "BB",
  By: "BY",
  Be: "BE",
  Bz: "BZ",
  Bj: "BJ",
  Bm: "BM",
  Bt: "BT",
  Bo: "BO",
  Ba: "BA",
  Bw: "BW",
  Bv: "BV",
  Br: "BR",
  Io: "IO",
  Bn: "BN",
  Bg: "BG",
  Bf: "BF",
  Bi: "BI",
  Kh: "KH",
  Cm: "CM",
  Ca: "CA",
  Cv: "CV",
  Ky: "KY",
  Cf: "CF",
  Td: "TD",
  Cl: "CL",
  Cn: "CN",
  Cx: "CX",
  Cc: "CC",
  Co: "CO",
  Km: "KM",
  Cg: "CG",
  Cd: "CD",
  Ck: "CK",
  Cr: "CR",
  Ci: "CI",
  Hr: "HR",
  Cu: "CU",
  Cw: "CW",
  Cy: "CY",
  Cz: "CZ",
  Dk: "DK",
  Dj: "DJ",
  Dm: "DM",
  Do: "DO",
  Ec: "EC",
  Eg: "EG",
  Sv: "SV",
  Gq: "GQ",
  Er: "ER",
  Ee: "EE",
  Et: "ET",
  Fk: "FK",
  Fo: "FO",
  Fj: "FJ",
  Fi: "FI",
  Fr: "FR",
  Gf: "GF",
  Pf: "PF",
  Tf: "TF",
  Ga: "GA",
  Gm: "GM",
  Ge: "GE",
  De: "DE",
  Gh: "GH",
  Gi: "GI",
  Gr: "GR",
  Gl: "GL",
  Gd: "GD",
  Gp: "GP",
  Gu: "GU",
  Gt: "GT",
  Gg: "GG",
  Gn: "GN",
  Gw: "GW",
  Gy: "GY",
  Ht: "HT",
  Hm: "HM",
  Va: "VA",
  Hn: "HN",
  Hk: "HK",
  Hu: "HU",
  Is: "IS",
  In: "IN",
  Id: "ID",
  Ir: "IR",
  Iq: "IQ",
  Ie: "IE",
  Im: "IM",
  Il: "IL",
  It: "IT",
  Jm: "JM",
  Jp: "JP",
  Je: "JE",
  Jo: "JO",
  Kz: "KZ",
  Ke: "KE",
  Ki: "KI",
  Kr: "KR",
  Kw: "KW",
  Kg: "KG",
  La: "LA",
  Lv: "LV",
  Lb: "LB",
  Ls: "LS",
  Lr: "LR",
  Ly: "LY",
  Li: "LI",
  Lt: "LT",
  Lu: "LU",
  Mo: "MO",
  Mk: "MK",
  Mg: "MG",
  Mw: "MW",
  My: "MY",
  Mv: "MV",
  Ml: "ML",
  Mt: "MT",
  Mh: "MH",
  Mq: "MQ",
  Mr: "MR",
  Mu: "MU",
  Yt: "YT",
  Mx: "MX",
  Fm: "FM",
  Md: "MD",
  Mc: "MC",
  Mn: "MN",
  Me: "ME",
  Ms: "MS",
  Ma: "MA",
  Mz: "MZ",
  Mm: "MM",
  Na: "NA",
  Nr: "NR",
  Np: "NP",
  Nl: "NL",
  An: "AN",
  Nc: "NC",
  Nz: "NZ",
  Ni: "NI",
  Ne: "NE",
  Ng: "NG",
  Nu: "NU",
  Nf: "NF",
  Mp: "MP",
  No: "NO",
  Om: "OM",
  Pk: "PK",
  Pw: "PW",
  Ps: "PS",
  Pa: "PA",
  Pg: "PG",
  Py: "PY",
  Pe: "PE",
  Ph: "PH",
  Pn: "PN",
  Pl: "PL",
  Pt: "PT",
  Pr: "PR",
  Qa: "QA",
  Re: "RE",
  Ro: "RO",
  Ru: "RU",
  Rw: "RW",
  Bl: "BL",
  Sh: "SH",
  Kn: "KN",
  Lc: "LC",
  Mf: "MF",
  Pm: "PM",
  Vc: "VC",
  Ws: "WS",
  Sm: "SM",
  St: "ST",
  Sa: "SA",
  Sn: "SN",
  Ss: "SS",
  Rs: "RS",
  Sc: "SC",
  Sl: "SL",
  Sg: "SG",
  Sk: "SK",
  Si: "SI",
  Sb: "SB",
  So: "SO",
  Za: "ZA",
  Gs: "GS",
  Es: "ES",
  Lk: "LK",
  Sd: "SD",
  Sr: "SR",
  Sj: "SJ",
  Sz: "SZ",
  Se: "SE",
  Ch: "CH",
  Sy: "SY",
  Tw: "TW",
  Tj: "TJ",
  Tz: "TZ",
  Th: "TH",
  Tl: "TL",
  Tg: "TG",
  Tk: "TK",
  To: "TO",
  Tt: "TT",
  Tn: "TN",
  Tr: "TR",
  Tm: "TM",
  Tc: "TC",
  Tv: "TV",
  Ug: "UG",
  Ua: "UA",
  Ae: "AE",
  Gb: "GB",
  Us: "US",
  Um: "UM",
  Uy: "UY",
  Uz: "UZ",
  Vu: "VU",
  Ve: "VE",
  Vn: "VN",
  Vg: "VG",
  Vi: "VI",
  Wf: "WF",
  Eh: "EH",
  Ye: "YE",
  Zm: "ZM",
  Zw: "ZW",
  Bq: "BQ",
  Kp: "KP",
  Sx: "SX",
  Xk: "XK",
  Ac: "AC",
} as const;
/**
 * The ISO 3166-1 alpha-2 country code for the country this location is in.
 */
export type InputValueCountryCode1 = ClosedEnum<typeof InputValueCountryCode1>;

export type InputValue10 = {
  /**
   * The first line of the address. Note that this value is not currently represented in the UI but will be persisted and readable through API calls.
   */
  line1: string | null;
  /**
   * The second line of the address. Note that this value is not currently represented in the UI but will be persisted and readable through API calls.
   */
  line2: string | null;
  /**
   * The third line of the address. Note that this value is not currently represented in the UI but will be persisted and readable through API calls.
   */
  line3: string | null;
  /**
   * The fourth line of the address. Note that this value is not currently represented in the UI but will be persisted and readable through API calls.
   */
  line4: string | null;
  /**
   * The town, neighborhood or area the location is in.
   */
  locality: string | null;
  /**
   * The state, county, province or region that the location is in.
   */
  region: string | null;
  /**
   * The postcode or zip code for the location. Note that this value is not currently represented in the UI but will be persisted and readable through API calls.}
   */
  postcode: string | null;
  /**
   * The ISO 3166-1 alpha-2 country code for the country this location is in.
   */
  countryCode: InputValueCountryCode1 | null;
  /**
   * The latitude of the location. Validated by the regular expression `/^[-+]?([1-8]?\d(\.\d+)?|90(\.0+)?)$/`. Values are stored with up to 9 decimal places of precision. Note that this value is not currently represented in the UI but will be persisted and readable through API calls.}
   */
  latitude: string | null;
  /**
   * The longitude of the location. Validated by the regular expression `/^[-+]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?)$/`. Values are stored with up to 9 decimal places of precision. Note that this value is not currently represented in the UI but will be persisted and readable through API calls.}
   */
  longitude: string | null;
};

/**
 * The type of interaction e.g. calendar or email.
 */
export const InputValueInteractionType = {
  CalendarEvent: "calendar-event",
  Call: "call",
  ChatThread: "chat-thread",
  Email: "email",
  InPersonMeeting: "in-person-meeting",
  Meeting: "meeting",
} as const;
/**
 * The type of interaction e.g. calendar or email.
 */
export type InputValueInteractionType = ClosedEnum<
  typeof InputValueInteractionType
>;

/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export const InputValueType = {
  ApiToken: "api-token",
  WorkspaceMember: "workspace-member",
  System: "system",
  App: "app",
} as const;
/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export type InputValueType = ClosedEnum<typeof InputValueType>;

/**
 * The actor that created this value.
 */
export type InputValueOwnerActor = {
  /**
   * An ID to identify the actor.
   */
  id?: string | null | undefined;
  /**
   * The type of actor. [Read more information on actor types here](/docs/actors).
   */
  type?: InputValueType | null | undefined;
};

export type InputValue9 = {
  /**
   * The type of interaction e.g. calendar or email.
   */
  interactionType: InputValueInteractionType;
  /**
   * When the interaction occurred.
   */
  interactedAt: Date;
  /**
   * The actor that created this value.
   */
  ownerActor: InputValueOwnerActor;
};

export type SlugOrIdOfMatchingAttribute5 = {
  /**
   * A raw text field. Values are limited to 10MB.
   */
  value?: string | undefined;
};

/**
 * The ISO 3166-1 alpha-2 country code representing the country that this phone number belongs to.
 */
export const SlugOrIdOfMatchingAttributeCountryCode = {
  Af: "AF",
  Ax: "AX",
  Al: "AL",
  Dz: "DZ",
  As: "AS",
  Ad: "AD",
  Ao: "AO",
  Ai: "AI",
  Aq: "AQ",
  Ag: "AG",
  Ar: "AR",
  Am: "AM",
  Aw: "AW",
  Au: "AU",
  At: "AT",
  Az: "AZ",
  Bs: "BS",
  Bh: "BH",
  Bd: "BD",
  Bb: "BB",
  By: "BY",
  Be: "BE",
  Bz: "BZ",
  Bj: "BJ",
  Bm: "BM",
  Bt: "BT",
  Bo: "BO",
  Ba: "BA",
  Bw: "BW",
  Bv: "BV",
  Br: "BR",
  Io: "IO",
  Bn: "BN",
  Bg: "BG",
  Bf: "BF",
  Bi: "BI",
  Kh: "KH",
  Cm: "CM",
  Ca: "CA",
  Cv: "CV",
  Ky: "KY",
  Cf: "CF",
  Td: "TD",
  Cl: "CL",
  Cn: "CN",
  Cx: "CX",
  Cc: "CC",
  Co: "CO",
  Km: "KM",
  Cg: "CG",
  Cd: "CD",
  Ck: "CK",
  Cr: "CR",
  Ci: "CI",
  Hr: "HR",
  Cu: "CU",
  Cw: "CW",
  Cy: "CY",
  Cz: "CZ",
  Dk: "DK",
  Dj: "DJ",
  Dm: "DM",
  Do: "DO",
  Ec: "EC",
  Eg: "EG",
  Sv: "SV",
  Gq: "GQ",
  Er: "ER",
  Ee: "EE",
  Et: "ET",
  Fk: "FK",
  Fo: "FO",
  Fj: "FJ",
  Fi: "FI",
  Fr: "FR",
  Gf: "GF",
  Pf: "PF",
  Tf: "TF",
  Ga: "GA",
  Gm: "GM",
  Ge: "GE",
  De: "DE",
  Gh: "GH",
  Gi: "GI",
  Gr: "GR",
  Gl: "GL",
  Gd: "GD",
  Gp: "GP",
  Gu: "GU",
  Gt: "GT",
  Gg: "GG",
  Gn: "GN",
  Gw: "GW",
  Gy: "GY",
  Ht: "HT",
  Hm: "HM",
  Va: "VA",
  Hn: "HN",
  Hk: "HK",
  Hu: "HU",
  Is: "IS",
  In: "IN",
  Id: "ID",
  Ir: "IR",
  Iq: "IQ",
  Ie: "IE",
  Im: "IM",
  Il: "IL",
  It: "IT",
  Jm: "JM",
  Jp: "JP",
  Je: "JE",
  Jo: "JO",
  Kz: "KZ",
  Ke: "KE",
  Ki: "KI",
  Kr: "KR",
  Kw: "KW",
  Kg: "KG",
  La: "LA",
  Lv: "LV",
  Lb: "LB",
  Ls: "LS",
  Lr: "LR",
  Ly: "LY",
  Li: "LI",
  Lt: "LT",
  Lu: "LU",
  Mo: "MO",
  Mk: "MK",
  Mg: "MG",
  Mw: "MW",
  My: "MY",
  Mv: "MV",
  Ml: "ML",
  Mt: "MT",
  Mh: "MH",
  Mq: "MQ",
  Mr: "MR",
  Mu: "MU",
  Yt: "YT",
  Mx: "MX",
  Fm: "FM",
  Md: "MD",
  Mc: "MC",
  Mn: "MN",
  Me: "ME",
  Ms: "MS",
  Ma: "MA",
  Mz: "MZ",
  Mm: "MM",
  Na: "NA",
  Nr: "NR",
  Np: "NP",
  Nl: "NL",
  An: "AN",
  Nc: "NC",
  Nz: "NZ",
  Ni: "NI",
  Ne: "NE",
  Ng: "NG",
  Nu: "NU",
  Nf: "NF",
  Mp: "MP",
  No: "NO",
  Om: "OM",
  Pk: "PK",
  Pw: "PW",
  Ps: "PS",
  Pa: "PA",
  Pg: "PG",
  Py: "PY",
  Pe: "PE",
  Ph: "PH",
  Pn: "PN",
  Pl: "PL",
  Pt: "PT",
  Pr: "PR",
  Qa: "QA",
  Re: "RE",
  Ro: "RO",
  Ru: "RU",
  Rw: "RW",
  Bl: "BL",
  Sh: "SH",
  Kn: "KN",
  Lc: "LC",
  Mf: "MF",
  Pm: "PM",
  Vc: "VC",
  Ws: "WS",
  Sm: "SM",
  St: "ST",
  Sa: "SA",
  Sn: "SN",
  Ss: "SS",
  Rs: "RS",
  Sc: "SC",
  Sl: "SL",
  Sg: "SG",
  Sk: "SK",
  Si: "SI",
  Sb: "SB",
  So: "SO",
  Za: "ZA",
  Gs: "GS",
  Es: "ES",
  Lk: "LK",
  Sd: "SD",
  Sr: "SR",
  Sj: "SJ",
  Sz: "SZ",
  Se: "SE",
  Ch: "CH",
  Sy: "SY",
  Tw: "TW",
  Tj: "TJ",
  Tz: "TZ",
  Th: "TH",
  Tl: "TL",
  Tg: "TG",
  Tk: "TK",
  To: "TO",
  Tt: "TT",
  Tn: "TN",
  Tr: "TR",
  Tm: "TM",
  Tc: "TC",
  Tv: "TV",
  Ug: "UG",
  Ua: "UA",
  Ae: "AE",
  Gb: "GB",
  Us: "US",
  Um: "UM",
  Uy: "UY",
  Uz: "UZ",
  Vu: "VU",
  Ve: "VE",
  Vn: "VN",
  Vg: "VG",
  Vi: "VI",
  Wf: "WF",
  Eh: "EH",
  Ye: "YE",
  Zm: "ZM",
  Zw: "ZW",
  Bq: "BQ",
  Kp: "KP",
  Sx: "SX",
  Xk: "XK",
  Ac: "AC",
} as const;
/**
 * The ISO 3166-1 alpha-2 country code representing the country that this phone number belongs to.
 */
export type SlugOrIdOfMatchingAttributeCountryCode = ClosedEnum<
  typeof SlugOrIdOfMatchingAttributeCountryCode
>;

export type SlugOrIdOfMatchingAttribute4 = {
  /**
   * The raw, original phone number, as inputted.
   */
  originalPhoneNumber?: string | undefined;
  /**
   * The ISO 3166-1 alpha-2 country code representing the country that this phone number belongs to.
   */
  countryCode?: SlugOrIdOfMatchingAttributeCountryCode | null | undefined;
};

export type SlugOrIdOfMatchingAttribute3 = {
  /**
   * Numbers are persisted as 64 bit floats.
   */
  value?: number | undefined;
};

export type SlugOrIdOfMatchingAttribute2 = {
  /**
   * An email address string
   */
  emailAddress?: string | undefined;
};

export type SlugOrIdOfMatchingAttribute1 = {
  /**
   * The full domain of the website.
   */
  domain?: string | undefined;
};

export type SlugOrIdOfMatchingAttributeUnion =
  | SlugOrIdOfMatchingAttribute1
  | SlugOrIdOfMatchingAttribute2
  | SlugOrIdOfMatchingAttribute3
  | SlugOrIdOfMatchingAttribute4
  | SlugOrIdOfMatchingAttribute5;

export type InputValue8 = {
  /**
   * A UUID or slug to identify the object that the referenced record belongs to.
   */
  targetObject: string;
  /**
   * In addition to referencing records directly by record ID, you may also reference by a matching attribute of your choice. For example, if you want to add a reference to the person record with email "alice@website.com", you should pass a value with `target_object` set to `"people"` and `email_addresses` set to `[{email_address:"alice@website.com"}]`. The key should be the slug or ID of the matching attribute you would like to use and the value should be an array containing a single value of the appropriate attribute type (as specified below). Matching on multiple values is not currently supported. Matching attributes must be unique. This process is similar to how you use the `matching_attribute` query param in Attio's [assert endpoints](/rest-api/endpoint-reference/records/assert-a-record).
   */
  slugOrIdOfMatchingAttribute: Array<
    | SlugOrIdOfMatchingAttribute1
    | SlugOrIdOfMatchingAttribute2
    | SlugOrIdOfMatchingAttribute3
    | SlugOrIdOfMatchingAttribute4
    | SlugOrIdOfMatchingAttribute5
  >;
};

export type InputValue7 = {
  /**
   * A UUID or slug to identify the object that the referenced record belongs to.
   */
  targetObject: string;
  /**
   * A UUID to identify the referenced record.
   */
  targetRecordId: string;
};

export type InputValue6 = {
  /**
   * An email address string
   */
  emailAddress?: string | undefined;
};

export type InputValue5 = {
  /**
   * The full domain of the website.
   */
  domain?: string | undefined;
};

export type InputValue4 = {
  /**
   * A date represents a single calendar year, month and day, independent of timezone. If hours, months, seconds or timezones are provided, they will be trimmed. For example, "2023" and "2023-01" will be coerced into "2023-01-01", and "2023-01-02", "2023-01-02T13:00", "2023-01-02T14:00:00", "2023-01-02T15:00:00.000000000", and "2023-01-02T15:00:00.000000000+02:00" will all be coerced to "2023-01-02". If a timezone is provided that would result in a different calendar date in UTC, the date will be coerced to UTC and then the timezone component will be trimmed. For example, the value "2023-01-02T23:00:00-10:00" will be returned as "2023-01-03". The maximum date is "9999-12-31".
   */
  value: string;
};

export type InputValue3 = {
  /**
   * A numerical representation of the currency value. A decimal with a max of 4 decimal places.
   */
  currencyValue: number;
};

export type InputValue2 = {
  /**
   * A boolean representing whether the checkbox is checked or not. The string values 'true' and 'false' are also accepted.
   */
  value: boolean;
};

export type InputValue1 = {
  /**
   * Workspace member actors can be referenced by email address as well as actor ID.
   */
  workspaceMemberEmailAddress: string;
};

/**
 * The type of the referenced actor. Currently, only workspace members can be written into actor reference attributes. [Read more information on actor types here](/docs/actors).
 */
export const InputValueReferencedActorType = {
  WorkspaceMember: "workspace-member",
} as const;
/**
 * The type of the referenced actor. Currently, only workspace members can be written into actor reference attributes. [Read more information on actor types here](/docs/actors).
 */
export type InputValueReferencedActorType = ClosedEnum<
  typeof InputValueReferencedActorType
>;

export type InputValueWorkspaceMember = {
  /**
   * The type of the referenced actor. Currently, only workspace members can be written into actor reference attributes. [Read more information on actor types here](/docs/actors).
   */
  referencedActorType: InputValueReferencedActorType;
  /**
   * The ID of the referenced Actor.
   */
  referencedActorId: string;
};

/**
 * A union of possible value types, as required in request bodies.
 */
export type InputValueUnion =
  | InputValue10
  | InputValue9
  | InputValueWorkspaceMember
  | InputValue7
  | InputValue8
  | InputValue1
  | InputValue2
  | InputValue3
  | InputValue4
  | InputValue11
  | InputValue13
  | InputValue14
  | InputValue15
  | InputValue16
  | InputValue17
  | InputValue18
  | InputValue5
  | InputValue6
  | InputValue12;

/** @internal */
export type InputValue18$Outbound = {
  value: string;
};

/** @internal */
export const InputValue18$outboundSchema: z.ZodMiniType<
  InputValue18$Outbound,
  InputValue18
> = z.object({
  value: z.pipe(
    z.date(),
    z.transform(v => v.toISOString().slice(0, "YYYY-MM-DD".length)),
  ),
});

export function inputValue18ToJSON(inputValue18: InputValue18): string {
  return JSON.stringify(InputValue18$outboundSchema.parse(inputValue18));
}

/** @internal */
export type InputValue17$Outbound = {
  value: string;
};

/** @internal */
export const InputValue17$outboundSchema: z.ZodMiniType<
  InputValue17$Outbound,
  InputValue17
> = z.object({
  value: z.string(),
});

export function inputValue17ToJSON(inputValue17: InputValue17): string {
  return JSON.stringify(InputValue17$outboundSchema.parse(inputValue17));
}

/** @internal */
export type InputValue16$Outbound = {
  option: string;
};

/** @internal */
export const InputValue16$outboundSchema: z.ZodMiniType<
  InputValue16$Outbound,
  InputValue16
> = z.object({
  option: z.string(),
});

export function inputValue16ToJSON(inputValue16: InputValue16): string {
  return JSON.stringify(InputValue16$outboundSchema.parse(inputValue16));
}

/** @internal */
export type InputValue15$Outbound = {
  value: number;
};

/** @internal */
export const InputValue15$outboundSchema: z.ZodMiniType<
  InputValue15$Outbound,
  InputValue15
> = z.object({
  value: z.number(),
});

export function inputValue15ToJSON(inputValue15: InputValue15): string {
  return JSON.stringify(InputValue15$outboundSchema.parse(inputValue15));
}

/** @internal */
export type InputValue14$Outbound = {
  status: string;
};

/** @internal */
export const InputValue14$outboundSchema: z.ZodMiniType<
  InputValue14$Outbound,
  InputValue14
> = z.object({
  status: z.string(),
});

export function inputValue14ToJSON(inputValue14: InputValue14): string {
  return JSON.stringify(InputValue14$outboundSchema.parse(inputValue14));
}

/** @internal */
export const InputValueCountryCode2$outboundSchema: z.ZodMiniEnum<
  typeof InputValueCountryCode2
> = z.enum(InputValueCountryCode2);

/** @internal */
export type InputValue13$Outbound = {
  original_phone_number: string;
  country_code?: string | null | undefined;
};

/** @internal */
export const InputValue13$outboundSchema: z.ZodMiniType<
  InputValue13$Outbound,
  InputValue13
> = z.pipe(
  z.object({
    originalPhoneNumber: z.string(),
    countryCode: z.optional(z.nullable(InputValueCountryCode2$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      originalPhoneNumber: "original_phone_number",
      countryCode: "country_code",
    });
  }),
);

export function inputValue13ToJSON(inputValue13: InputValue13): string {
  return JSON.stringify(InputValue13$outboundSchema.parse(inputValue13));
}

/** @internal */
export type InputValue12$Outbound = {
  first_name?: string | undefined;
  last_name?: string | undefined;
  full_name?: string | undefined;
};

/** @internal */
export const InputValue12$outboundSchema: z.ZodMiniType<
  InputValue12$Outbound,
  InputValue12
> = z.pipe(
  z.object({
    firstName: z.optional(z.string()),
    lastName: z.optional(z.string()),
    fullName: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      firstName: "first_name",
      lastName: "last_name",
      fullName: "full_name",
    });
  }),
);

export function inputValue12ToJSON(inputValue12: InputValue12): string {
  return JSON.stringify(InputValue12$outboundSchema.parse(inputValue12));
}

/** @internal */
export type InputValue11$Outbound = {
  value: number;
};

/** @internal */
export const InputValue11$outboundSchema: z.ZodMiniType<
  InputValue11$Outbound,
  InputValue11
> = z.object({
  value: z.number(),
});

export function inputValue11ToJSON(inputValue11: InputValue11): string {
  return JSON.stringify(InputValue11$outboundSchema.parse(inputValue11));
}

/** @internal */
export const InputValueCountryCode1$outboundSchema: z.ZodMiniEnum<
  typeof InputValueCountryCode1
> = z.enum(InputValueCountryCode1);

/** @internal */
export type InputValue10$Outbound = {
  line_1: string | null;
  line_2: string | null;
  line_3: string | null;
  line_4: string | null;
  locality: string | null;
  region: string | null;
  postcode: string | null;
  country_code: string | null;
  latitude: string | null;
  longitude: string | null;
};

/** @internal */
export const InputValue10$outboundSchema: z.ZodMiniType<
  InputValue10$Outbound,
  InputValue10
> = z.pipe(
  z.object({
    line1: z.nullable(z.string()),
    line2: z.nullable(z.string()),
    line3: z.nullable(z.string()),
    line4: z.nullable(z.string()),
    locality: z.nullable(z.string()),
    region: z.nullable(z.string()),
    postcode: z.nullable(z.string()),
    countryCode: z.nullable(InputValueCountryCode1$outboundSchema),
    latitude: z.nullable(z.string()),
    longitude: z.nullable(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      line1: "line_1",
      line2: "line_2",
      line3: "line_3",
      line4: "line_4",
      countryCode: "country_code",
    });
  }),
);

export function inputValue10ToJSON(inputValue10: InputValue10): string {
  return JSON.stringify(InputValue10$outboundSchema.parse(inputValue10));
}

/** @internal */
export const InputValueInteractionType$outboundSchema: z.ZodMiniEnum<
  typeof InputValueInteractionType
> = z.enum(InputValueInteractionType);

/** @internal */
export const InputValueType$outboundSchema: z.ZodMiniEnum<
  typeof InputValueType
> = z.enum(InputValueType);

/** @internal */
export type InputValueOwnerActor$Outbound = {
  id?: string | null | undefined;
  type?: string | null | undefined;
};

/** @internal */
export const InputValueOwnerActor$outboundSchema: z.ZodMiniType<
  InputValueOwnerActor$Outbound,
  InputValueOwnerActor
> = z.object({
  id: z.optional(z.nullable(z.string())),
  type: z.optional(z.nullable(InputValueType$outboundSchema)),
});

export function inputValueOwnerActorToJSON(
  inputValueOwnerActor: InputValueOwnerActor,
): string {
  return JSON.stringify(
    InputValueOwnerActor$outboundSchema.parse(inputValueOwnerActor),
  );
}

/** @internal */
export type InputValue9$Outbound = {
  interaction_type: string;
  interacted_at: string;
  owner_actor: InputValueOwnerActor$Outbound;
};

/** @internal */
export const InputValue9$outboundSchema: z.ZodMiniType<
  InputValue9$Outbound,
  InputValue9
> = z.pipe(
  z.object({
    interactionType: InputValueInteractionType$outboundSchema,
    interactedAt: z.pipe(z.date(), z.transform(v => v.toISOString())),
    ownerActor: z.lazy(() => InputValueOwnerActor$outboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      interactionType: "interaction_type",
      interactedAt: "interacted_at",
      ownerActor: "owner_actor",
    });
  }),
);

export function inputValue9ToJSON(inputValue9: InputValue9): string {
  return JSON.stringify(InputValue9$outboundSchema.parse(inputValue9));
}

/** @internal */
export type SlugOrIdOfMatchingAttribute5$Outbound = {
  value?: string | undefined;
};

/** @internal */
export const SlugOrIdOfMatchingAttribute5$outboundSchema: z.ZodMiniType<
  SlugOrIdOfMatchingAttribute5$Outbound,
  SlugOrIdOfMatchingAttribute5
> = z.object({
  value: z.optional(z.string()),
});

export function slugOrIdOfMatchingAttribute5ToJSON(
  slugOrIdOfMatchingAttribute5: SlugOrIdOfMatchingAttribute5,
): string {
  return JSON.stringify(
    SlugOrIdOfMatchingAttribute5$outboundSchema.parse(
      slugOrIdOfMatchingAttribute5,
    ),
  );
}

/** @internal */
export const SlugOrIdOfMatchingAttributeCountryCode$outboundSchema:
  z.ZodMiniEnum<typeof SlugOrIdOfMatchingAttributeCountryCode> = z.enum(
    SlugOrIdOfMatchingAttributeCountryCode,
  );

/** @internal */
export type SlugOrIdOfMatchingAttribute4$Outbound = {
  original_phone_number?: string | undefined;
  country_code?: string | null | undefined;
};

/** @internal */
export const SlugOrIdOfMatchingAttribute4$outboundSchema: z.ZodMiniType<
  SlugOrIdOfMatchingAttribute4$Outbound,
  SlugOrIdOfMatchingAttribute4
> = z.pipe(
  z.object({
    originalPhoneNumber: z.optional(z.string()),
    countryCode: z.optional(
      z.nullable(SlugOrIdOfMatchingAttributeCountryCode$outboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      originalPhoneNumber: "original_phone_number",
      countryCode: "country_code",
    });
  }),
);

export function slugOrIdOfMatchingAttribute4ToJSON(
  slugOrIdOfMatchingAttribute4: SlugOrIdOfMatchingAttribute4,
): string {
  return JSON.stringify(
    SlugOrIdOfMatchingAttribute4$outboundSchema.parse(
      slugOrIdOfMatchingAttribute4,
    ),
  );
}

/** @internal */
export type SlugOrIdOfMatchingAttribute3$Outbound = {
  value?: number | undefined;
};

/** @internal */
export const SlugOrIdOfMatchingAttribute3$outboundSchema: z.ZodMiniType<
  SlugOrIdOfMatchingAttribute3$Outbound,
  SlugOrIdOfMatchingAttribute3
> = z.object({
  value: z.optional(z.number()),
});

export function slugOrIdOfMatchingAttribute3ToJSON(
  slugOrIdOfMatchingAttribute3: SlugOrIdOfMatchingAttribute3,
): string {
  return JSON.stringify(
    SlugOrIdOfMatchingAttribute3$outboundSchema.parse(
      slugOrIdOfMatchingAttribute3,
    ),
  );
}

/** @internal */
export type SlugOrIdOfMatchingAttribute2$Outbound = {
  email_address?: string | undefined;
};

/** @internal */
export const SlugOrIdOfMatchingAttribute2$outboundSchema: z.ZodMiniType<
  SlugOrIdOfMatchingAttribute2$Outbound,
  SlugOrIdOfMatchingAttribute2
> = z.pipe(
  z.object({
    emailAddress: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      emailAddress: "email_address",
    });
  }),
);

export function slugOrIdOfMatchingAttribute2ToJSON(
  slugOrIdOfMatchingAttribute2: SlugOrIdOfMatchingAttribute2,
): string {
  return JSON.stringify(
    SlugOrIdOfMatchingAttribute2$outboundSchema.parse(
      slugOrIdOfMatchingAttribute2,
    ),
  );
}

/** @internal */
export type SlugOrIdOfMatchingAttribute1$Outbound = {
  domain?: string | undefined;
};

/** @internal */
export const SlugOrIdOfMatchingAttribute1$outboundSchema: z.ZodMiniType<
  SlugOrIdOfMatchingAttribute1$Outbound,
  SlugOrIdOfMatchingAttribute1
> = z.object({
  domain: z.optional(z.string()),
});

export function slugOrIdOfMatchingAttribute1ToJSON(
  slugOrIdOfMatchingAttribute1: SlugOrIdOfMatchingAttribute1,
): string {
  return JSON.stringify(
    SlugOrIdOfMatchingAttribute1$outboundSchema.parse(
      slugOrIdOfMatchingAttribute1,
    ),
  );
}

/** @internal */
export type SlugOrIdOfMatchingAttributeUnion$Outbound =
  | SlugOrIdOfMatchingAttribute1$Outbound
  | SlugOrIdOfMatchingAttribute2$Outbound
  | SlugOrIdOfMatchingAttribute3$Outbound
  | SlugOrIdOfMatchingAttribute4$Outbound
  | SlugOrIdOfMatchingAttribute5$Outbound;

/** @internal */
export const SlugOrIdOfMatchingAttributeUnion$outboundSchema: z.ZodMiniType<
  SlugOrIdOfMatchingAttributeUnion$Outbound,
  SlugOrIdOfMatchingAttributeUnion
> = smartUnion([
  z.lazy(() => SlugOrIdOfMatchingAttribute1$outboundSchema),
  z.lazy(() => SlugOrIdOfMatchingAttribute2$outboundSchema),
  z.lazy(() => SlugOrIdOfMatchingAttribute3$outboundSchema),
  z.lazy(() => SlugOrIdOfMatchingAttribute4$outboundSchema),
  z.lazy(() => SlugOrIdOfMatchingAttribute5$outboundSchema),
]);

export function slugOrIdOfMatchingAttributeUnionToJSON(
  slugOrIdOfMatchingAttributeUnion: SlugOrIdOfMatchingAttributeUnion,
): string {
  return JSON.stringify(
    SlugOrIdOfMatchingAttributeUnion$outboundSchema.parse(
      slugOrIdOfMatchingAttributeUnion,
    ),
  );
}

/** @internal */
export type InputValue8$Outbound = {
  target_object: string;
  "[slug_or_id_of_matching_attribute]": Array<
    | SlugOrIdOfMatchingAttribute1$Outbound
    | SlugOrIdOfMatchingAttribute2$Outbound
    | SlugOrIdOfMatchingAttribute3$Outbound
    | SlugOrIdOfMatchingAttribute4$Outbound
    | SlugOrIdOfMatchingAttribute5$Outbound
  >;
};

/** @internal */
export const InputValue8$outboundSchema: z.ZodMiniType<
  InputValue8$Outbound,
  InputValue8
> = z.pipe(
  z.object({
    targetObject: z.string(),
    slugOrIdOfMatchingAttribute: z.array(smartUnion([
      z.lazy(() => SlugOrIdOfMatchingAttribute1$outboundSchema),
      z.lazy(() => SlugOrIdOfMatchingAttribute2$outboundSchema),
      z.lazy(() => SlugOrIdOfMatchingAttribute3$outboundSchema),
      z.lazy(() => SlugOrIdOfMatchingAttribute4$outboundSchema),
      z.lazy(() => SlugOrIdOfMatchingAttribute5$outboundSchema),
    ])),
  }),
  z.transform((v) => {
    return remap$(v, {
      targetObject: "target_object",
      slugOrIdOfMatchingAttribute: "[slug_or_id_of_matching_attribute]",
    });
  }),
);

export function inputValue8ToJSON(inputValue8: InputValue8): string {
  return JSON.stringify(InputValue8$outboundSchema.parse(inputValue8));
}

/** @internal */
export type InputValue7$Outbound = {
  target_object: string;
  target_record_id: string;
};

/** @internal */
export const InputValue7$outboundSchema: z.ZodMiniType<
  InputValue7$Outbound,
  InputValue7
> = z.pipe(
  z.object({
    targetObject: z.string(),
    targetRecordId: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      targetObject: "target_object",
      targetRecordId: "target_record_id",
    });
  }),
);

export function inputValue7ToJSON(inputValue7: InputValue7): string {
  return JSON.stringify(InputValue7$outboundSchema.parse(inputValue7));
}

/** @internal */
export type InputValue6$Outbound = {
  email_address?: string | undefined;
};

/** @internal */
export const InputValue6$outboundSchema: z.ZodMiniType<
  InputValue6$Outbound,
  InputValue6
> = z.pipe(
  z.object({
    emailAddress: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      emailAddress: "email_address",
    });
  }),
);

export function inputValue6ToJSON(inputValue6: InputValue6): string {
  return JSON.stringify(InputValue6$outboundSchema.parse(inputValue6));
}

/** @internal */
export type InputValue5$Outbound = {
  domain?: string | undefined;
};

/** @internal */
export const InputValue5$outboundSchema: z.ZodMiniType<
  InputValue5$Outbound,
  InputValue5
> = z.object({
  domain: z.optional(z.string()),
});

export function inputValue5ToJSON(inputValue5: InputValue5): string {
  return JSON.stringify(InputValue5$outboundSchema.parse(inputValue5));
}

/** @internal */
export type InputValue4$Outbound = {
  value: string;
};

/** @internal */
export const InputValue4$outboundSchema: z.ZodMiniType<
  InputValue4$Outbound,
  InputValue4
> = z.object({
  value: z.string(),
});

export function inputValue4ToJSON(inputValue4: InputValue4): string {
  return JSON.stringify(InputValue4$outboundSchema.parse(inputValue4));
}

/** @internal */
export type InputValue3$Outbound = {
  currency_value: number;
};

/** @internal */
export const InputValue3$outboundSchema: z.ZodMiniType<
  InputValue3$Outbound,
  InputValue3
> = z.pipe(
  z.object({
    currencyValue: z.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      currencyValue: "currency_value",
    });
  }),
);

export function inputValue3ToJSON(inputValue3: InputValue3): string {
  return JSON.stringify(InputValue3$outboundSchema.parse(inputValue3));
}

/** @internal */
export type InputValue2$Outbound = {
  value: boolean;
};

/** @internal */
export const InputValue2$outboundSchema: z.ZodMiniType<
  InputValue2$Outbound,
  InputValue2
> = z.object({
  value: z.boolean(),
});

export function inputValue2ToJSON(inputValue2: InputValue2): string {
  return JSON.stringify(InputValue2$outboundSchema.parse(inputValue2));
}

/** @internal */
export type InputValue1$Outbound = {
  workspace_member_email_address: string;
};

/** @internal */
export const InputValue1$outboundSchema: z.ZodMiniType<
  InputValue1$Outbound,
  InputValue1
> = z.pipe(
  z.object({
    workspaceMemberEmailAddress: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      workspaceMemberEmailAddress: "workspace_member_email_address",
    });
  }),
);

export function inputValue1ToJSON(inputValue1: InputValue1): string {
  return JSON.stringify(InputValue1$outboundSchema.parse(inputValue1));
}

/** @internal */
export const InputValueReferencedActorType$outboundSchema: z.ZodMiniEnum<
  typeof InputValueReferencedActorType
> = z.enum(InputValueReferencedActorType);

/** @internal */
export type InputValueWorkspaceMember$Outbound = {
  referenced_actor_type: string;
  referenced_actor_id: string;
};

/** @internal */
export const InputValueWorkspaceMember$outboundSchema: z.ZodMiniType<
  InputValueWorkspaceMember$Outbound,
  InputValueWorkspaceMember
> = z.pipe(
  z.object({
    referencedActorType: InputValueReferencedActorType$outboundSchema,
    referencedActorId: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      referencedActorType: "referenced_actor_type",
      referencedActorId: "referenced_actor_id",
    });
  }),
);

export function inputValueWorkspaceMemberToJSON(
  inputValueWorkspaceMember: InputValueWorkspaceMember,
): string {
  return JSON.stringify(
    InputValueWorkspaceMember$outboundSchema.parse(inputValueWorkspaceMember),
  );
}

/** @internal */
export type InputValueUnion$Outbound =
  | InputValue10$Outbound
  | InputValue9$Outbound
  | InputValueWorkspaceMember$Outbound
  | InputValue7$Outbound
  | InputValue8$Outbound
  | InputValue1$Outbound
  | InputValue2$Outbound
  | InputValue3$Outbound
  | InputValue4$Outbound
  | InputValue11$Outbound
  | InputValue13$Outbound
  | InputValue14$Outbound
  | InputValue15$Outbound
  | InputValue16$Outbound
  | InputValue17$Outbound
  | InputValue18$Outbound
  | InputValue5$Outbound
  | InputValue6$Outbound
  | InputValue12$Outbound;

/** @internal */
export const InputValueUnion$outboundSchema: z.ZodMiniType<
  InputValueUnion$Outbound,
  InputValueUnion
> = smartUnion([
  z.lazy(() => InputValue10$outboundSchema),
  z.lazy(() => InputValue9$outboundSchema),
  z.lazy(() => InputValueWorkspaceMember$outboundSchema),
  z.lazy(() => InputValue7$outboundSchema),
  z.lazy(() => InputValue8$outboundSchema),
  z.lazy(() => InputValue1$outboundSchema),
  z.lazy(() => InputValue2$outboundSchema),
  z.lazy(() => InputValue3$outboundSchema),
  z.lazy(() => InputValue4$outboundSchema),
  z.lazy(() => InputValue11$outboundSchema),
  z.lazy(() => InputValue13$outboundSchema),
  z.lazy(() => InputValue14$outboundSchema),
  z.lazy(() => InputValue15$outboundSchema),
  z.lazy(() => InputValue16$outboundSchema),
  z.lazy(() => InputValue17$outboundSchema),
  z.lazy(() => InputValue18$outboundSchema),
  z.lazy(() => InputValue5$outboundSchema),
  z.lazy(() => InputValue6$outboundSchema),
  z.lazy(() => InputValue12$outboundSchema),
]);

export function inputValueUnionToJSON(
  inputValueUnion: InputValueUnion,
): string {
  return JSON.stringify(InputValueUnion$outboundSchema.parse(inputValueUnion));
}
