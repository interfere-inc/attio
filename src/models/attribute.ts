/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminated-union.js";
import { discriminatedUnion } from "../types/discriminated-union.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";
import { OutputValue, OutputValue$inboundSchema } from "./output-value.js";

export type AttributeId = {
  /**
   * A UUID representing the workspace this attribute belongs to.
   */
  workspaceId: string;
  /**
   * A UUID to identify the object or list that this attribute belongs to
   */
  objectId: string;
  /**
   * A UUID to identify this attribute.
   */
  attributeId: string;
};

/**
 * The type of the attribute.
 */
export const AttributeTypeEnum = {
  Text: "text",
  Number: "number",
  Checkbox: "checkbox",
  Currency: "currency",
  Date: "date",
  Timestamp: "timestamp",
  Rating: "rating",
  Status: "status",
  Select: "select",
  RecordReference: "record-reference",
  ActorReference: "actor-reference",
  Location: "location",
  Domain: "domain",
  EmailAddress: "email-address",
  PhoneNumber: "phone-number",
  Interaction: "interaction",
  PersonalName: "personal-name",
} as const;
/**
 * The type of the attribute.
 */
export type AttributeTypeEnum = OpenEnum<typeof AttributeTypeEnum>;

export type DefaultValueStatic = {
  type: "static";
  template: Array<OutputValue>;
};

/**
 * For actor reference attributes, you may pass a dynamic value of `"current-user"`. When creating new records or entries, this will cause the actor reference value to be populated with either the workspace member or API token that created the record/entry.
 */
export const Template = {
  CurrentUser: "current-user",
} as const;
/**
 * For actor reference attributes, you may pass a dynamic value of `"current-user"`. When creating new records or entries, this will cause the actor reference value to be populated with either the workspace member or API token that created the record/entry.
 */
export type Template = ClosedEnum<typeof Template>;

export type DefaultValueDynamic = {
  type: "dynamic";
  template: any;
};

/**
 * The default value for this attribute. Static values are used to directly populate values using their contents. Dynamic values are used to lookup data at the point of creation. For example, you could use a dynamic value to insert a value for the currently logged in user. Which default values are available is dependent on the type of the attribute.
 */
export type DefaultValue =
  | DefaultValueDynamic
  | DefaultValueStatic
  | discriminatedUnionTypes.Unknown<"type">;

export type RelationshipId = {
  /**
   * A UUID representing the workspace this attribute belongs to.
   */
  workspaceId: string;
  /**
   * A UUID to identify the object or list that this attribute belongs to
   */
  objectId: string;
  /**
   * A UUID to identify this attribute.
   */
  attributeId: string;
};

/**
 * If this attribute is related to another attribute, this is an object that includes an `id` property that identifies the other attribute. `null` means no relationship exists. See [the help center](https://attio.com/help/reference/managing-your-data/attributes#relationship-attributes) for more details about relationship attributes.
 */
export type Relationship = {
  id: RelationshipId;
  /**
   * The slug of the object that the related attribute belongs to.
   */
  objectSlug: string;
  /**
   * The title of the related attribute.
   */
  title: string;
  /**
   * The API slug identifying the related attribute.
   */
  apiSlug: string;
  /**
   * Whether the related attribute supports selecting multiple values. Combined with the parent attribute's `is_multiselect`, this determines the relationship type: both `false` = one-to-one, parent `true` + related `false` = many-to-one, parent `false` + related `true` = one-to-many, both `true` = many-to-many.
   */
  isMultiselect: boolean;
};

/**
 * The ISO4217 code representing the currency that values for this attribute should be stored in.
 */
export const DefaultCurrencyCode = {
  Ars: "ARS",
  Aud: "AUD",
  Brl: "BRL",
  Bgn: "BGN",
  Cad: "CAD",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Czk: "CZK",
  Dkk: "DKK",
  Eur: "EUR",
  Hkd: "HKD",
  Huf: "HUF",
  Isk: "ISK",
  Inr: "INR",
  Ils: "ILS",
  Jpy: "JPY",
  Kes: "KES",
  Krw: "KRW",
  Myr: "MYR",
  Mxn: "MXN",
  Ntd: "NTD",
  Nzd: "NZD",
  Ngn: "NGN",
  Nok: "NOK",
  Xpf: "XPF",
  Pen: "PEN",
  Php: "PHP",
  Pln: "PLN",
  Gbp: "GBP",
  Rwf: "RWF",
  Sar: "SAR",
  Sgd: "SGD",
  Zar: "ZAR",
  Sek: "SEK",
  Chf: "CHF",
  Thb: "THB",
  Aed: "AED",
  Uyu: "UYU",
  Usd: "USD",
} as const;
/**
 * The ISO4217 code representing the currency that values for this attribute should be stored in.
 */
export type DefaultCurrencyCode = OpenEnum<typeof DefaultCurrencyCode>;

/**
 * How the currency should be displayed across the app. "code" will display the ISO currency code e.g. "USD", "name" will display the localized currency name e.g. "British pound", "narrowSymbol" will display "$1" instead of "US$1" and "symbol" will display a localized currency symbol such as "$".
 */
export const DisplayType = {
  Code: "code",
  Name: "name",
  NarrowSymbol: "narrowSymbol",
  Symbol: "symbol",
} as const;
/**
 * How the currency should be displayed across the app. "code" will display the ISO currency code e.g. "USD", "name" will display the localized currency name e.g. "British pound", "narrowSymbol" will display "$1" instead of "US$1" and "symbol" will display a localized currency symbol such as "$".
 */
export type DisplayType = OpenEnum<typeof DisplayType>;

/**
 * Configuration available for attributes of type "currency".
 */
export type Currency = {
  /**
   * The ISO4217 code representing the currency that values for this attribute should be stored in.
   */
  defaultCurrencyCode: DefaultCurrencyCode | null;
  /**
   * How the currency should be displayed across the app. "code" will display the ISO currency code e.g. "USD", "name" will display the localized currency name e.g. "British pound", "narrowSymbol" will display "$1" instead of "US$1" and "symbol" will display a localized currency symbol such as "$".
   */
  displayType: DisplayType | null;
};

/**
 * Configuration available for attributes of type "record-reference".
 */
export type RecordReference = {
  /**
   * A list of UUIDs to indicate which objects records are allowed to belong to. Leave empty to to allow records from all object types.
   */
  allowedObjectIds: Array<string> | null;
};

/**
 * Additional, type-dependent configuration for the attribute.
 */
export type Config = {
  /**
   * Configuration available for attributes of type "currency".
   */
  currency: Currency;
  /**
   * Configuration available for attributes of type "record-reference".
   */
  recordReference: RecordReference;
};

export type Attribute = {
  id: AttributeId;
  /**
   * A title for the attribute, to be displayed across the app.
   */
  title: string;
  /**
   * A text description of the attribute.
   */
  description: string | null;
  /**
   * A unique slug for the attribute for use in API responses and URLs. Formatted in snake case.
   */
  apiSlug: string;
  /**
   * The type of the attribute.
   */
  type: AttributeTypeEnum;
  /**
   * `true` if this is an Attio system-defined attribute, `false` if defined by a user or non-Attio system.
   */
  isSystemAttribute: boolean;
  /**
   * Whether or not this attribute can be written to. Can only be false when `is_system_attribute` is `true` (user-defined attributes are always writeable). If `false`, this usually means the attribute is enriched by Attio.
   */
  isWritable: boolean;
  /**
   * When `is_required` is `true`, new records/entries must have a value for this attribute. If `false`, values may be `null`. This value does not affect existing data and you do not need to backfill `null` values if changing `is_required` from `false` to `true`.
   */
  isRequired: boolean;
  /**
   * Whether or not new values for this attribute must be unique. Uniqueness restrictions are only applied to new data and do not apply retroactively to previously created data.
   */
  isUnique: boolean;
  /**
   * Whether or not this attribute can have multiple values. Multiselect is only available on some value types.
   */
  isMultiselect: boolean;
  /**
   * Whether this attribute has a default value enabled. Must be `true` when `is_required` is `true`.
   */
  isDefaultValueEnabled: boolean;
  /**
   * Whether this attribute has been archived. Archived attributes are hidden from most UI, but can be restored either over the API or in workspace settings. See the [guide on archiving and deleting](/docs/archiving-vs-deleting)for more information.
   */
  isArchived: boolean;
  /**
   * The default value for this attribute. Static values are used to directly populate values using their contents. Dynamic values are used to lookup data at the point of creation. For example, you could use a dynamic value to insert a value for the currently logged in user. Which default values are available is dependent on the type of the attribute.
   */
  defaultValue:
    | DefaultValueDynamic
    | DefaultValueStatic
    | discriminatedUnionTypes.Unknown<"type">
    | null;
  /**
   * If this attribute is related to another attribute, this is an object that includes an `id` property that identifies the other attribute. `null` means no relationship exists. See [the help center](https://attio.com/help/reference/managing-your-data/attributes#relationship-attributes) for more details about relationship attributes.
   */
  relationship: Relationship | null;
  /**
   * When this attribute was created.
   */
  createdAt: string;
  /**
   * Additional, type-dependent configuration for the attribute.
   */
  config: Config;
};

/** @internal */
export const AttributeId$inboundSchema: z.ZodMiniType<AttributeId, unknown> = z
  .pipe(
    z.object({
      workspace_id: types.string(),
      object_id: types.string(),
      attribute_id: types.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        "workspace_id": "workspaceId",
        "object_id": "objectId",
        "attribute_id": "attributeId",
      });
    }),
  );

export function attributeIdFromJSON(
  jsonString: string,
): SafeParseResult<AttributeId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AttributeId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AttributeId' from JSON`,
  );
}

/** @internal */
export const AttributeTypeEnum$inboundSchema: z.ZodMiniType<
  AttributeTypeEnum,
  unknown
> = openEnums.inboundSchema(AttributeTypeEnum);

/** @internal */
export const DefaultValueStatic$inboundSchema: z.ZodMiniType<
  DefaultValueStatic,
  unknown
> = z.object({
  type: types.literal("static"),
  template: z.array(OutputValue$inboundSchema),
});

export function defaultValueStaticFromJSON(
  jsonString: string,
): SafeParseResult<DefaultValueStatic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultValueStatic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultValueStatic' from JSON`,
  );
}

/** @internal */
export const Template$inboundSchema: z.ZodMiniEnum<typeof Template> = z.enum(
  Template,
);

/** @internal */
export const DefaultValueDynamic$inboundSchema: z.ZodMiniType<
  DefaultValueDynamic,
  unknown
> = z.object({
  type: types.literal("dynamic"),
  template: z.any(),
});

export function defaultValueDynamicFromJSON(
  jsonString: string,
): SafeParseResult<DefaultValueDynamic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultValueDynamic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultValueDynamic' from JSON`,
  );
}

/** @internal */
export const DefaultValue$inboundSchema: z.ZodMiniType<DefaultValue, unknown> =
  discriminatedUnion("type", {
    dynamic: z.lazy(() => DefaultValueDynamic$inboundSchema),
    static: z.lazy(() => DefaultValueStatic$inboundSchema),
  });

export function defaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultValue' from JSON`,
  );
}

/** @internal */
export const RelationshipId$inboundSchema: z.ZodMiniType<
  RelationshipId,
  unknown
> = z.pipe(
  z.object({
    workspace_id: types.string(),
    object_id: types.string(),
    attribute_id: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "workspace_id": "workspaceId",
      "object_id": "objectId",
      "attribute_id": "attributeId",
    });
  }),
);

export function relationshipIdFromJSON(
  jsonString: string,
): SafeParseResult<RelationshipId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RelationshipId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RelationshipId' from JSON`,
  );
}

/** @internal */
export const Relationship$inboundSchema: z.ZodMiniType<Relationship, unknown> =
  z.pipe(
    z.object({
      id: z.lazy(() => RelationshipId$inboundSchema),
      object_slug: types.string(),
      title: types.string(),
      api_slug: types.string(),
      is_multiselect: types.boolean(),
    }),
    z.transform((v) => {
      return remap$(v, {
        "object_slug": "objectSlug",
        "api_slug": "apiSlug",
        "is_multiselect": "isMultiselect",
      });
    }),
  );

export function relationshipFromJSON(
  jsonString: string,
): SafeParseResult<Relationship, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Relationship$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Relationship' from JSON`,
  );
}

/** @internal */
export const DefaultCurrencyCode$inboundSchema: z.ZodMiniType<
  DefaultCurrencyCode,
  unknown
> = openEnums.inboundSchema(DefaultCurrencyCode);

/** @internal */
export const DisplayType$inboundSchema: z.ZodMiniType<DisplayType, unknown> =
  openEnums.inboundSchema(DisplayType);

/** @internal */
export const Currency$inboundSchema: z.ZodMiniType<Currency, unknown> = z.pipe(
  z.object({
    default_currency_code: types.nullable(DefaultCurrencyCode$inboundSchema),
    display_type: types.nullable(DisplayType$inboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      "default_currency_code": "defaultCurrencyCode",
      "display_type": "displayType",
    });
  }),
);

export function currencyFromJSON(
  jsonString: string,
): SafeParseResult<Currency, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Currency$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Currency' from JSON`,
  );
}

/** @internal */
export const RecordReference$inboundSchema: z.ZodMiniType<
  RecordReference,
  unknown
> = z.pipe(
  z.object({
    allowed_object_ids: types.nullable(z.array(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "allowed_object_ids": "allowedObjectIds",
    });
  }),
);

export function recordReferenceFromJSON(
  jsonString: string,
): SafeParseResult<RecordReference, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RecordReference$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RecordReference' from JSON`,
  );
}

/** @internal */
export const Config$inboundSchema: z.ZodMiniType<Config, unknown> = z.pipe(
  z.object({
    currency: z.lazy(() => Currency$inboundSchema),
    record_reference: z.lazy(() => RecordReference$inboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      "record_reference": "recordReference",
    });
  }),
);

export function configFromJSON(
  jsonString: string,
): SafeParseResult<Config, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Config$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Config' from JSON`,
  );
}

/** @internal */
export const Attribute$inboundSchema: z.ZodMiniType<Attribute, unknown> = z
  .pipe(
    z.object({
      id: z.lazy(() => AttributeId$inboundSchema),
      title: types.string(),
      description: types.nullable(types.string()),
      api_slug: types.string(),
      type: AttributeTypeEnum$inboundSchema,
      is_system_attribute: types.boolean(),
      is_writable: types.boolean(),
      is_required: types.boolean(),
      is_unique: types.boolean(),
      is_multiselect: types.boolean(),
      is_default_value_enabled: types.boolean(),
      is_archived: types.boolean(),
      default_value: types.nullable(
        discriminatedUnion("type", {
          dynamic: z.lazy(() => DefaultValueDynamic$inboundSchema),
          static: z.lazy(() => DefaultValueStatic$inboundSchema),
        }),
      ),
      relationship: types.nullable(z.lazy(() => Relationship$inboundSchema)),
      created_at: types.string(),
      config: z.lazy(() => Config$inboundSchema),
    }),
    z.transform((v) => {
      return remap$(v, {
        "api_slug": "apiSlug",
        "is_system_attribute": "isSystemAttribute",
        "is_writable": "isWritable",
        "is_required": "isRequired",
        "is_unique": "isUnique",
        "is_multiselect": "isMultiselect",
        "is_default_value_enabled": "isDefaultValueEnabled",
        "is_archived": "isArchived",
        "default_value": "defaultValue",
        "created_at": "createdAt",
      });
    }),
  );

export function attributeFromJSON(
  jsonString: string,
): SafeParseResult<Attribute, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Attribute$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Attribute' from JSON`,
  );
}
