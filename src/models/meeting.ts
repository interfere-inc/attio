/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

export type MeetingId = {
  /**
   * The ID of the workspace the meeting belongs to.
   */
  workspaceId: string;
  /**
   * The ID of the Attio meeting.
   */
  meetingId: string;
};

export type Start2 = {
  /**
   * If an all day event, a date representing when the meeting starts.
   */
  date: string;
};

export type Start1 = {
  /**
   * If a non-all day event, a datetime representing when the meeting starts. Datetimes are formatted as UTC if no timezone is available. If a timezone is available, the datetime will offset using the specified timezone.
   */
  datetime: string;
  /**
   * The IANA timezone in which the meeting starts, if available.
   */
  timezone: string | null;
};

export type StartUnion = Start1 | Start2;

export type End2 = {
  /**
   * If an all day event, a date representing when the meeting ends.
   */
  date: string;
};

export type End1 = {
  /**
   * A datetime representing when the meeting ends. All day meetings will return a date whereas non-all day meetings will return a datetime. Datetimes do not include timezone information; please refer to `timezone` for timezone information. Following iCalendar RFC 5545, the `end_at` property is exclusive, meaning that the meeting ends before the specified time, not at it. For example, a one day meeting on June 3rd would have an `end_at` of June 4th, not June 3rd; a one hour meeting starting at 14:00 would have an `end_at` of 15:00, not 14:00.
   */
  datetime: string;
  /**
   * The IANA timezone in which the meeting ends, if available.
   */
  timezone: string | null;
};

export type EndUnion = End1 | End2;

/**
 * The status of the individual meeting participant.
 */
export const StatusEnum = {
  Accepted: "accepted",
  Tentative: "tentative",
  Declined: "declined",
  Pending: "pending",
} as const;
/**
 * The status of the individual meeting participant.
 */
export type StatusEnum = OpenEnum<typeof StatusEnum>;

export type Participant = {
  /**
   * The status of the individual meeting participant.
   */
  status: StatusEnum;
  /**
   * Whether or not the participant is the organizer of the meeting.
   */
  isOrganizer: boolean;
  /**
   * The normalized email address of the meeting participant.
   */
  emailAddress: string | null;
};

export type MeetingLinkedRecord = {
  /**
   * The slug of the object the meeting linked record belongs to.
   */
  objectSlug: string;
  /**
   * The ID of the object the meeting linked record belongs to.
   */
  objectId: string;
  /**
   * The ID of the meeting linked record.
   */
  recordId: string;
};

/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export const MeetingType = {
  ApiToken: "api-token",
  WorkspaceMember: "workspace-member",
  System: "system",
  App: "app",
} as const;
/**
 * The type of actor. [Read more information on actor types here](/docs/actors).
 */
export type MeetingType = OpenEnum<typeof MeetingType>;

/**
 * The actor that created this meeting.
 */
export type MeetingCreatedByActor = {
  /**
   * An ID to identify the actor.
   */
  id?: string | null | undefined;
  /**
   * The type of actor. [Read more information on actor types here](/docs/actors).
   */
  type?: MeetingType | null | undefined;
};

export type Meeting = {
  id: MeetingId;
  /**
   * The title of the meeting.
   */
  title: string;
  /**
   * The description of the meeting.
   */
  description: string;
  /**
   * Whether or not the meeting is an all day event. All day events may span multiple days.
   */
  isAllDay: boolean;
  start: Start1 | Start2;
  end: End1 | End2;
  participants: Array<Participant>;
  /**
   * A list of records that are linked to the meeting. Participants with matching person records are automatically linked to the meeting but other records may also be linked explicitly.
   */
  linkedRecords: Array<MeetingLinkedRecord>;
  /**
   * Timestamp representing when the meeting was created.
   */
  createdAt: string;
  /**
   * The actor that created this meeting.
   */
  createdByActor: MeetingCreatedByActor;
};

/** @internal */
export const MeetingId$inboundSchema: z.ZodMiniType<MeetingId, unknown> = z
  .pipe(
    z.object({
      workspace_id: types.string(),
      meeting_id: types.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        "workspace_id": "workspaceId",
        "meeting_id": "meetingId",
      });
    }),
  );

export function meetingIdFromJSON(
  jsonString: string,
): SafeParseResult<MeetingId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MeetingId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MeetingId' from JSON`,
  );
}

/** @internal */
export const Start2$inboundSchema: z.ZodMiniType<Start2, unknown> = z.object({
  date: types.string(),
});

export function start2FromJSON(
  jsonString: string,
): SafeParseResult<Start2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Start2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Start2' from JSON`,
  );
}

/** @internal */
export const Start1$inboundSchema: z.ZodMiniType<Start1, unknown> = z.object({
  datetime: types.string(),
  timezone: types.nullable(types.string()),
});

export function start1FromJSON(
  jsonString: string,
): SafeParseResult<Start1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Start1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Start1' from JSON`,
  );
}

/** @internal */
export const StartUnion$inboundSchema: z.ZodMiniType<StartUnion, unknown> =
  smartUnion([
    z.lazy(() => Start1$inboundSchema),
    z.lazy(() => Start2$inboundSchema),
  ]);

export function startUnionFromJSON(
  jsonString: string,
): SafeParseResult<StartUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StartUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StartUnion' from JSON`,
  );
}

/** @internal */
export const End2$inboundSchema: z.ZodMiniType<End2, unknown> = z.object({
  date: types.string(),
});

export function end2FromJSON(
  jsonString: string,
): SafeParseResult<End2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => End2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'End2' from JSON`,
  );
}

/** @internal */
export const End1$inboundSchema: z.ZodMiniType<End1, unknown> = z.object({
  datetime: types.string(),
  timezone: types.nullable(types.string()),
});

export function end1FromJSON(
  jsonString: string,
): SafeParseResult<End1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => End1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'End1' from JSON`,
  );
}

/** @internal */
export const EndUnion$inboundSchema: z.ZodMiniType<EndUnion, unknown> =
  smartUnion([
    z.lazy(() => End1$inboundSchema),
    z.lazy(() => End2$inboundSchema),
  ]);

export function endUnionFromJSON(
  jsonString: string,
): SafeParseResult<EndUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EndUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EndUnion' from JSON`,
  );
}

/** @internal */
export const StatusEnum$inboundSchema: z.ZodMiniType<StatusEnum, unknown> =
  openEnums.inboundSchema(StatusEnum);

/** @internal */
export const Participant$inboundSchema: z.ZodMiniType<Participant, unknown> = z
  .pipe(
    z.object({
      status: StatusEnum$inboundSchema,
      is_organizer: types.boolean(),
      email_address: types.nullable(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_organizer": "isOrganizer",
        "email_address": "emailAddress",
      });
    }),
  );

export function participantFromJSON(
  jsonString: string,
): SafeParseResult<Participant, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Participant$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Participant' from JSON`,
  );
}

/** @internal */
export const MeetingLinkedRecord$inboundSchema: z.ZodMiniType<
  MeetingLinkedRecord,
  unknown
> = z.pipe(
  z.object({
    object_slug: types.string(),
    object_id: types.string(),
    record_id: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "object_slug": "objectSlug",
      "object_id": "objectId",
      "record_id": "recordId",
    });
  }),
);

export function meetingLinkedRecordFromJSON(
  jsonString: string,
): SafeParseResult<MeetingLinkedRecord, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MeetingLinkedRecord$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MeetingLinkedRecord' from JSON`,
  );
}

/** @internal */
export const MeetingType$inboundSchema: z.ZodMiniType<MeetingType, unknown> =
  openEnums.inboundSchema(MeetingType);

/** @internal */
export const MeetingCreatedByActor$inboundSchema: z.ZodMiniType<
  MeetingCreatedByActor,
  unknown
> = z.object({
  id: z.optional(z.nullable(types.string())),
  type: z.optional(z.nullable(MeetingType$inboundSchema)),
});

export function meetingCreatedByActorFromJSON(
  jsonString: string,
): SafeParseResult<MeetingCreatedByActor, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MeetingCreatedByActor$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MeetingCreatedByActor' from JSON`,
  );
}

/** @internal */
export const Meeting$inboundSchema: z.ZodMiniType<Meeting, unknown> = z.pipe(
  z.object({
    id: z.lazy(() => MeetingId$inboundSchema),
    title: types.string(),
    description: types.string(),
    is_all_day: types.boolean(),
    start: smartUnion([
      z.lazy(() => Start1$inboundSchema),
      z.lazy(() => Start2$inboundSchema),
    ]),
    end: smartUnion([
      z.lazy(() => End1$inboundSchema),
      z.lazy(() => End2$inboundSchema),
    ]),
    participants: z.array(z.lazy(() => Participant$inboundSchema)),
    linked_records: z.array(z.lazy(() => MeetingLinkedRecord$inboundSchema)),
    created_at: types.string(),
    created_by_actor: z.lazy(() => MeetingCreatedByActor$inboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_all_day": "isAllDay",
      "linked_records": "linkedRecords",
      "created_at": "createdAt",
      "created_by_actor": "createdByActor",
    });
  }),
);

export function meetingFromJSON(
  jsonString: string,
): SafeParseResult<Meeting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Meeting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Meeting' from JSON`,
  );
}
